#!/usr/bin/env python3
"""
Tagger - Audio file tag and filename manager using mutagen

This script manages tags and filenames for .mp3 and .m4a files.
It can also convert .aac files to .m4a format (lossless container conversion).
"""

__version__ = "1.22.0"

import argparse
import hashlib
import os
import re
import shutil
import subprocess
import sys
from pathlib import Path

import yaml

try:
    from mutagen.id3 import (
        APIC,
        COMM,
        ID3,
        TALB,
        TCMP,
        TCON,
        TDRC,
        TIT2,
        TPE1,
        TPE2,
        TPOS,
        TRCK,
        TXXX,
    )
    from mutagen.mp3 import MP3
    from mutagen.mp4 import MP4, MP4Cover
except ImportError:
    print(
        "Error: mutagen is not installed. Please install it with: pip install mutagen",
        file=sys.stderr,
    )
    sys.exit(1)

try:
    from pydantic import BaseModel, Field, ValidationError, field_validator
except ImportError:
    print(
        "Error: pydantic is not installed. Please install it with: pip install pydantic",
        file=sys.stderr,
    )
    sys.exit(1)


# Pydantic models for YAML schema validation
class Defaults(BaseModel):
    """Default values applied to all files"""

    model_config = {"extra": "forbid"}

    album: str | None = None
    albumartist: str | None = None
    genre: str | None = None
    year: int | None = None
    artwork: str | None = None
    compilation: bool | None = None
    label: str | None = None
    bandcamp_id: str | None = None
    disc: int | None = None
    comment: str | None = None

    @field_validator("year")
    @classmethod
    def validate_year(cls, v: int | None) -> int | None:
        """Validate year is reasonable"""
        if v is not None and (v < 1900 or v > 2100):
            raise ValueError("Year must be between 1900 and 2100")
        return v

    @field_validator("disc")
    @classmethod
    def validate_disc(cls, v: int | None) -> int | None:
        """Validate disc number is positive"""
        if v is not None and v < 1:
            raise ValueError("Disc number must be positive")
        return v


class FileEntry(BaseModel):
    """Schema for a single file entry in the YAML"""

    model_config = {"extra": "forbid"}

    filename: str = Field(..., description="Original filename")
    track: int | None = None
    artist: str | None = None
    title: str | None = None
    album: str | None = None
    albumartist: str | None = None
    genre: str | None = None
    year: int | None = None
    artwork: str | None = None
    compilation: bool | None = None
    label: str | None = None
    bandcamp_id: str | None = None
    disc: int | None = None
    comment: str | None = None

    @field_validator("track")
    @classmethod
    def validate_track(cls, v: int | None) -> int | None:
        """Validate track number is positive"""
        if v is not None and v < 1:
            raise ValueError("Track number must be positive")
        return v

    @field_validator("year")
    @classmethod
    def validate_year(cls, v: int | None) -> int | None:
        """Validate year is reasonable"""
        if v is not None and (v < 1900 or v > 2100):
            raise ValueError("Year must be between 1900 and 2100")
        return v

    @field_validator("disc")
    @classmethod
    def validate_disc(cls, v: int | None) -> int | None:
        """Validate disc number is positive"""
        if v is not None and v < 1:
            raise ValueError("Disc number must be positive")
        return v


class TaggerConfig(BaseModel):
    """Schema for the complete YAML configuration"""

    model_config = {"extra": "forbid"}

    defaults: Defaults | None = None
    files: list[FileEntry] = Field(..., min_length=1, description="List of audio files")

    @field_validator("files")
    @classmethod
    def validate_files_not_empty(cls, v: list[FileEntry]) -> list[FileEntry]:
        """Ensure files list is not empty"""
        if not v:
            raise ValueError("Files list cannot be empty")
        return v


class Tagger:
    """Main class for managing audio file tags and filenames"""

    SUPPORTED_EXTENSIONS = {".mp3", ".m4a"}

    # ANSI color codes
    COLORS = {
        "reset": "\033[0m",
        "red": "\033[91m",
        "green": "\033[92m",
        "yellow": "\033[93m",
        "blue": "\033[94m",
        "magenta": "\033[95m",
        "cyan": "\033[96m",
        "white": "\033[97m",
        "bold": "\033[1m",
        "dim": "\033[2m",
    }

    def __init__(
        self,
        execute: bool = False,
        no_color: bool = False,
        prefer_filename: bool = False,
        thumbnail_crop: str = "auto",
    ):
        self.execute = execute
        self.dry_run = not execute
        self.no_color = no_color or not sys.stdout.isatty()
        self.prefer_filename = prefer_filename
        self.thumbnail_crop = thumbnail_crop  # "auto", "square", "none"

    def color(self, text: str, *colors: str) -> str:
        """Apply color to text"""
        if self.no_color:
            return text
        color_codes = "".join(self.COLORS.get(c, "") for c in colors)
        return f"{color_codes}{text}{self.COLORS['reset']}"

    def log(self, message: str):
        """Print log message"""
        prefix = "[DRY-RUN] " if self.dry_run else ""
        print(f"{prefix}{message}")

    def can_display_images(self) -> tuple[bool, str]:
        """Check if terminal supports inline image display

        Returns:
            Tuple of (can_display, reason)
        """
        # Check if stdout is a tty
        if not sys.stdout.isatty():
            return False, "stdout is not a terminal (redirected or piped)"

        # Check terminal type via environment variables
        term_program = os.environ.get("TERM_PROGRAM", "")
        term = os.environ.get("TERM", "")

        # Known terminals that support iTerm2 inline images protocol
        supported_terminals = {
            "iTerm.app": "iTerm2",
            "WezTerm": "WezTerm",
            "mintty": "mintty (with imgcat)",
            "Konsole": "Konsole (recent versions)",
        }

        if term_program in supported_terminals:
            return True, ""

        # WezTerm also sets TERM_PROGRAM_VERSION
        if "wezterm" in term.lower() or os.environ.get(
            "TERM_PROGRAM_VERSION", ""
        ).startswith("wezterm"):
            return True, ""

        # If we can't detect the terminal type, assume it doesn't support images
        if term_program:
            return False, f"terminal '{term_program}' may not support inline images"
        else:
            return False, f"terminal type '{term}' may not support inline images"

    def display_image_iterm2(self, image_path: Path, max_width: int = 60):
        """Display image using iTerm2 inline images protocol

        Args:
            image_path: Path to image file
            max_width: Maximum display width in character cells (default: 60)
        """
        import base64

        with open(image_path, "rb") as f:
            image_data = f.read()

        encoded = base64.b64encode(image_data).decode("ascii")

        # iTerm2 inline images protocol
        # ESC ] 1337 ; File=inline=1;width=N:<base64 data> BEL
        # Width is specified in character cells, height is automatic (preserves aspect ratio)
        print(f"\033]1337;File=inline=1;width={max_width}:{encoded}\007")

    def create_crop_preview(self, image_path: Path) -> Path:
        """Create preview image showing crop area

        Args:
            image_path: Path to original image

        Returns:
            Path to annotated image
        """
        from PIL import Image, ImageDraw

        img = Image.open(image_path)
        width, height = img.size

        # Create annotated version showing crop area
        annotated = img.copy()
        draw = ImageDraw.Draw(annotated)

        # Calculate crop coordinates
        if width > height:
            left = (width - height) // 2
            crop_box = (left, 0, left + height, height)
        else:
            top = (height - width) // 2
            crop_box = (0, top, width, top + width)

        # Draw semi-transparent overlay on areas that will be cropped out
        overlay = Image.new("RGBA", img.size, (0, 0, 0, 0))
        overlay_draw = ImageDraw.Draw(overlay)

        # Darken the areas outside crop box
        if width > height:
            # Left area
            overlay_draw.rectangle((0, 0, left, height), fill=(0, 0, 0, 128))
            # Right area
            overlay_draw.rectangle(
                (left + height, 0, width, height), fill=(0, 0, 0, 128)
            )
        else:
            # Top area
            overlay_draw.rectangle((0, 0, width, top), fill=(0, 0, 0, 128))
            # Bottom area
            overlay_draw.rectangle((0, top + width, width, height), fill=(0, 0, 0, 128))

        # Composite the overlay
        if annotated.mode != "RGBA":
            annotated = annotated.convert("RGBA")
        annotated = Image.alpha_composite(annotated, overlay)
        annotated = annotated.convert("RGB")

        # Draw crop box border
        draw = ImageDraw.Draw(annotated)
        draw.rectangle(crop_box, outline=(255, 0, 0), width=3)

        # Save temporary file
        annotated_path = image_path.with_suffix(".annotated.jpg")
        annotated.save(annotated_path, "JPEG", quality=95)

        return annotated_path

    def ask_thumbnail_crop(self, image_path: Path) -> bool:
        """Ask user whether to crop thumbnail to square

        Args:
            image_path: Path to downloaded thumbnail

        Returns:
            True if user wants to crop, False otherwise
        """
        # Check if we can display images
        can_display, reason = self.can_display_images()

        if not can_display:
            print("\n" + "=" * 60)
            print(self.color("Warning: Cannot display thumbnail preview", "yellow"))
            print("=" * 60)
            print(f"Reason: {reason}")
            print("\nSupported terminals: iTerm2, WezTerm, Konsole, mintty")
            print(
                f"Your terminal: TERM_PROGRAM={os.environ.get('TERM_PROGRAM', '(not set)')}, TERM={os.environ.get('TERM', '(not set)')}"
            )
            print("\nApplying default: Keep original thumbnail (no cropping)")
            print("=" * 60)
            return False  # Default: no cropping

        print("\n" + "=" * 60)
        print("YouTube Thumbnail Preview:")
        print("=" * 60)

        try:
            from PIL import Image

            img = Image.open(image_path)
            width, height = img.size

            # Only show preview if image is not already square
            if width != height:
                # Create preview image with crop area
                annotated_path = self.create_crop_preview(image_path)

                print(f"\nOriginal image with crop area (red border):")
                print(f"Dimensions: {width}x{height}")
                crop_size = min(width, height)
                print(f"Crop to: {crop_size}x{crop_size}")
                try:
                    self.display_image_iterm2(annotated_path)
                except Exception as e:
                    self.log(f"Warning: Could not display annotated image: {e}")

                # Clean up temporary file
                try:
                    annotated_path.unlink()
                except Exception:
                    pass
            else:
                print(f"\nImage is already square ({width}x{height})")
                try:
                    self.display_image_iterm2(image_path)
                except Exception as e:
                    self.log(f"Warning: Could not display image: {e}")

        except Exception as e:
            self.log(f"Warning: Could not create preview: {e}")
            # Fallback to showing original image
            try:
                self.display_image_iterm2(image_path)
            except Exception:
                pass

        print("\nWould you like to crop this thumbnail to a square?")
        print("  1. Keep original (rectangular)")
        print("  2. Crop to square (center crop)")
        print()

        while True:
            choice = input("Enter your choice (1 or 2) [1]: ").strip()
            if choice == "" or choice == "1":
                return False  # Keep original
            elif choice == "2":
                return True  # Crop to square
            else:
                print("Invalid choice. Please enter 1 or 2.")

    def get_artwork_hash(self, data: bytes) -> str:
        """Calculate SHA256 hash of artwork data"""
        return hashlib.sha256(data).hexdigest()

    def get_embedded_artwork(self, filepath: Path) -> bytes | None:
        """Extract embedded artwork from audio file"""
        ext = filepath.suffix.lower()

        try:
            if ext == ".mp3":
                audio = MP3(str(filepath), ID3=ID3)
                if audio.tags and "APIC:" in audio.tags:
                    return audio.tags["APIC:"].data
            elif ext == ".m4a":
                audio = MP4(str(filepath))
                if audio.tags and "covr" in audio.tags:
                    return bytes(audio.tags["covr"][0])
        except Exception:
            pass

        return None

    def compare_artwork(self, filepath: Path, artwork_path: str | None) -> bool:
        """Compare embedded artwork with external file

        Returns True if they are the same, False otherwise
        """
        if not artwork_path or artwork_path == "<embedded>":
            # Can't compare if no external file specified
            return False

        # Get embedded artwork
        embedded_data = self.get_embedded_artwork(filepath)
        if not embedded_data:
            # No embedded artwork
            return False

        # Get external artwork file
        external_path = Path(artwork_path)
        if not external_path.exists():
            # External file doesn't exist
            return False

        try:
            with open(external_path, "rb") as f:
                external_data = f.read()
        except Exception:
            return False

        # Compare hashes
        embedded_hash = self.get_artwork_hash(embedded_data)
        external_hash = self.get_artwork_hash(external_data)

        return embedded_hash == external_hash

    def find_audio_files(self, directory: str = ".") -> list[Path]:
        """Find all supported audio files in the directory"""
        path = Path(directory)
        files = []
        for ext in self.SUPPORTED_EXTENSIONS:
            files.extend(path.glob(f"*{ext}"))
        return sorted(files)

    def check_ffmpeg(self) -> bool:
        """Check if ffmpeg is available"""
        return shutil.which("ffmpeg") is not None

    def convert_aac_to_m4a(self, aac_file: Path) -> Path | None:
        """Convert AAC file to M4A format without re-encoding (lossless container conversion)"""
        if not self.check_ffmpeg():
            self.log("Warning: ffmpeg not found. Cannot convert .aac files to .m4a")
            return None

        m4a_file = aac_file.with_suffix(".m4a")

        if self.dry_run:
            self.log(f"Would convert: {aac_file.name} -> {m4a_file.name}")
            return m4a_file

        try:
            # Convert container without re-encoding (lossless)
            subprocess.run(
                ["ffmpeg", "-i", str(aac_file), "-c", "copy", "-y", str(m4a_file)],
                check=True,
                capture_output=True,
                text=True,
            )
            self.log(f"Converted: {aac_file.name} -> {m4a_file.name}")

            # Remove original .aac file after successful conversion
            aac_file.unlink()
            self.log(f"Removed original: {aac_file.name}")

            return m4a_file
        except subprocess.CalledProcessError as e:
            self.log(f"Error: Failed to convert {aac_file}: {e.stderr}")
            return None
        except Exception as e:
            self.log(f"Error: Could not convert {aac_file}: {e}")
            return None

    def find_and_convert_aac_files(self, directory: str = ".") -> list[Path]:
        """Find all .aac files and convert them to .m4a"""
        path = Path(directory)
        aac_files = list(path.glob("*.aac"))

        if not aac_files:
            return []

        self.log(f"Found {len(aac_files)} .aac file(s) to convert")

        converted_files = []
        for aac_file in aac_files:
            m4a_file = self.convert_aac_to_m4a(aac_file)
            if m4a_file:
                converted_files.append(m4a_file)

        return converted_files

    def extract_youtube_video_id(self, url: str) -> str | None:
        """Extract YouTube video ID from URL

        Supported URL patterns:
        - https://www.youtube.com/watch?v=VIDEO_ID
        - https://youtu.be/VIDEO_ID
        - https://m.youtube.com/watch?v=VIDEO_ID

        Returns:
            Video ID (11 characters) if found, None otherwise
        """
        match = re.search(
            r"(?:youtube\.com/watch\?v=|youtu\.be/)([A-Za-z0-9_-]{11})", url
        )
        return match.group(1) if match else None

    def extract_bandcamp_url_info(self, url: str) -> dict | None:
        """Extract Bandcamp URL information

        Supported URL patterns:
        - https://LABEL.bandcamp.com/album/ALBUM-SLUG
        - https://LABEL.bandcamp.com/track/TRACK-SLUG

        Returns:
            dict with 'label_slug', 'type' ('album' or 'track'), 'slug' if valid URL
            None if not a valid Bandcamp URL
        """
        match = re.match(r"https?://([^.]+)\.bandcamp\.com/(album|track)/([^/?]+)", url)
        if match:
            return {
                "label_slug": match.group(1),
                "type": match.group(2),  # 'album' or 'track'
                "slug": match.group(3),
            }
        return None

    def get_thumbnail_path_for_file(self, filepath: Path, video_id: str) -> Path:
        """Determine thumbnail filename for a file

        Naming strategy:
        - Single file in directory: cover.jpg
        - Multiple files: youtube_{VIDEO_ID}.jpg

        Args:
            filepath: Path to audio file
            video_id: YouTube video ID

        Returns:
            Path to thumbnail file
        """
        directory = filepath.parent
        audio_files = self.find_audio_files(str(directory))

        if len(audio_files) == 1:
            return directory / "cover.jpg"
        else:
            return directory / f"youtube_{video_id}.jpg"

    def get_bandcamp_artwork_path_for_file(
        self, filepath: Path, url_info: dict
    ) -> Path:
        """Determine artwork filename for Bandcamp

        Naming strategy:
        - Single file: cover.jpg
        - Multiple files from same album: cover.jpg (shared)
        - Multiple files from different albums: bandcamp_{label}_{slug}.jpg

        Args:
            filepath: Path to audio file
            url_info: Dict from extract_bandcamp_url_info()

        Returns:
            Path to artwork file
        """
        directory = filepath.parent
        audio_files = self.find_audio_files(str(directory))

        if len(audio_files) == 1:
            return directory / "cover.jpg"
        else:
            # Create unique identifier from URL
            identifier = f"{url_info['label_slug']}_{url_info['slug']}"
            return directory / f"bandcamp_{identifier}.jpg"

    def download_youtube_thumbnail(
        self, video_id: str, output_path: Path, crop: bool = False
    ) -> bool:
        """Download YouTube thumbnail and optionally crop to square

        Args:
            video_id: YouTube video ID (11 characters)
            output_path: Path where thumbnail should be saved
            crop: Whether to crop the thumbnail to square (default: False)

        Returns:
            True if successful, False otherwise
        """
        try:
            import yt_dlp

            temp_path = output_path.with_suffix("")
            ydl_opts = {
                "skip_download": True,
                "writethumbnail": True,
                "outtmpl": str(temp_path),
                "quiet": True,
                "no_warnings": True,
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                url = f"https://www.youtube.com/watch?v={video_id}"
                ydl.download([url])

            # Find downloaded thumbnail (yt-dlp adds extension)
            downloaded_files = list(temp_path.parent.glob(f"{temp_path.name}.*"))
            if not downloaded_files:
                raise Exception("Thumbnail not downloaded")

            downloaded_path = downloaded_files[0]

        except Exception as e:
            self.log(f"Warning: Failed to download thumbnail: {e}")
            return False

        # Process the thumbnail
        try:
            from PIL import Image

            if crop:
                # Crop to square (center crop)
                img = Image.open(downloaded_path)
                width, height = img.size

                if width > height:
                    left = (width - height) // 2
                    img_cropped = img.crop((left, 0, left + height, height))
                else:
                    top = (height - width) // 2
                    img_cropped = img.crop((0, top, width, top + width))

                # Save as JPEG
                img_cropped.save(output_path, "JPEG", quality=95)

                # Clean up temporary file
                if downloaded_path != output_path:
                    downloaded_path.unlink()
            else:
                # Keep original, just move/rename
                if downloaded_path != output_path:
                    # Re-save as JPEG to ensure consistent format
                    img = Image.open(downloaded_path)
                    img.save(output_path, "JPEG", quality=95)
                    downloaded_path.unlink()

        except Exception as e:
            self.log(f"Warning: Failed to process thumbnail: {e}")
            # Keep original if processing fails
            if downloaded_path != output_path:
                shutil.move(str(downloaded_path), str(output_path))

        return True

    def download_bandcamp_artwork(
        self, url: str, output_path: Path, crop: bool = False
    ) -> bool:
        """Download Bandcamp artwork and optionally crop to square

        Args:
            url: Bandcamp album or track URL
            output_path: Path where artwork should be saved
            crop: Whether to crop to square (default: False)

        Returns:
            True if successful, False otherwise
        """
        try:
            import yt_dlp

            temp_path = output_path.with_suffix("")
            ydl_opts = {
                "skip_download": True,
                "writethumbnail": True,
                "outtmpl": str(temp_path),
                "quiet": True,
                "no_warnings": True,
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([url])

            # Find downloaded artwork (yt-dlp adds extension)
            downloaded_files = list(temp_path.parent.glob(f"{temp_path.name}.*"))
            if not downloaded_files:
                raise Exception("Artwork not downloaded")

            downloaded_path = downloaded_files[0]

        except Exception as e:
            self.log(f"Warning: Failed to download Bandcamp artwork: {e}")
            return False

        # Process artwork (same logic as YouTube)
        try:
            from PIL import Image

            if crop:
                # Bandcamp artwork is usually already square, but crop if needed
                img = Image.open(downloaded_path)
                width, height = img.size

                if width > height:
                    left = (width - height) // 2
                    img_cropped = img.crop((left, 0, left + height, height))
                else:
                    top = (height - width) // 2
                    img_cropped = img.crop((0, top, width, top + width))

                img_cropped.save(output_path, "JPEG", quality=95)

                if downloaded_path != output_path:
                    downloaded_path.unlink()
            else:
                # Keep original, convert to JPEG
                if downloaded_path != output_path:
                    img = Image.open(downloaded_path)
                    img.save(output_path, "JPEG", quality=95)
                    downloaded_path.unlink()

        except Exception as e:
            self.log(f"Warning: Failed to process Bandcamp artwork: {e}")
            # Keep original if processing fails
            if downloaded_path != output_path:
                shutil.move(str(downloaded_path), str(output_path))

        return True

    def parse_filename(self, filename: str) -> dict[str, any]:
        """Parse metadata from filename

        Supported patterns (spaces are flexible, 1+ spaces allowed):
        - Label - Artist - Title [ID].mp3 -> label="Label", artist="Artist", title="Title", bandcamp_id="ID"
        - Label - Album - 01 Artist - Title.mp3 -> label="Label", album="Album", track=1, artist="Artist", title="Title"
        - Label - Album - 01 - Title.mp3 -> label="Label", album="Album", track=1, title="Title"
        - Artist - Title [YOUTUBE_ID].mp3 -> artist="Artist", title="Title", comment="https://www.youtube.com/watch?v=YOUTUBE_ID"
        - 1. Artist - Title.mp3 -> track=1, artist="Artist", title="Title"
        - 01 Artist - Title.mp3 -> track=1, artist="Artist", title="Title"
        - 01  - Title.mp3 -> track=1, artist="", title="Title"
        - 01 Title.mp3 -> track=1, artist="", title="Title"
        - Artist - Title.mp3 -> artist="Artist", title="Title"
        - Title.mp3 -> title="Title"
        """
        # Remove extension
        name = Path(filename).stem

        track = None
        artist = None
        title = None
        album = None
        label = None
        bandcamp_id = None
        comment = None

        # Check for YouTube ID pattern [VIDEO_ID] at the end
        # YouTube IDs are typically 11 characters: alphanumeric, hyphens, underscores
        youtube_match = re.search(r"\[([A-Za-z0-9_-]{11})\]$", name)
        if youtube_match:
            video_id = youtube_match.group(1)
            comment = f"https://www.youtube.com/watch?v={video_id}"
            # Remove the [VIDEO_ID] part from the name for further parsing
            name = name[: youtube_match.start()].strip()

        # Try patterns in order of specificity (spaces: 1+ allowed)
        # Pattern 0: "Label - Artist - Title [ID]" (Bandcamp format)
        match = re.match(r"^(.+?)\s+-\s+(.+?)\s+-\s+(.+?)\s+\[(\d+)\]$", name)
        if match:
            label = match.group(1).strip()
            artist = match.group(2).strip()
            title = match.group(3).strip()
            bandcamp_id = match.group(4).strip()
            return {
                "track": None,
                "artist": artist if artist else None,
                "title": title if title else None,
                "label": label if label else None,
                "bandcamp_id": bandcamp_id if bandcamp_id else None,
                "comment": comment,
            }

        # Pattern 0a: "Label - Album - 01 Artist - Title" (Label + Album + Track + Artist + Title)
        match = re.match(r"^(.+?)\s+-\s+(.+?)\s+-\s+(\d+)\s+(.+?)\s+-\s+(.+)$", name)
        if match:
            label = match.group(1).strip()
            album = match.group(2).strip()
            track = int(match.group(3))
            artist = match.group(4).strip()
            title = match.group(5).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": album if album else None,
                "label": label if label else None,
                "comment": comment,
            }

        # Pattern 0b: "Label - Album - 01 - Title" (Label + Album + Track + Title, no artist)
        match = re.match(r"^(.+?)\s+-\s+(.+?)\s+-\s+(\d+)\s+-\s+(.+)$", name)
        if match:
            label = match.group(1).strip()
            album = match.group(2).strip()
            track = int(match.group(3))
            title = match.group(4).strip()
            return {
                "track": track,
                "artist": None,
                "title": title if title else None,
                "album": album if album else None,
                "label": label if label else None,
                "comment": comment,
            }

        # Pattern 1: "1. Artist - Title" (track with dot + artist + title)
        match = re.match(r"^(\d+)\.\s+(.+?)\s+-\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = match.group(2).strip()
            title = match.group(3).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 2: "01 Artist - Title" (track + artist + title)
        match = re.match(r"^(\d+)\s+(.+?)\s+-\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = match.group(2).strip()
            title = match.group(3).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 3: "01  - Title" (track + title, no artist)
        match = re.match(r"^(\d+)\s+-\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = ""
            title = match.group(2).strip()
            return {
                "track": track,
                "artist": None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 4: "01 Title" (track + title, no separator)
        match = re.match(r"^(\d+)\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = ""
            title = match.group(2).strip()
            return {
                "track": track,
                "artist": None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 5: "Artist - Title" (artist + title, no track)
        match = re.match(r"^(.+?)\s+-\s+(.+)$", name)
        if match:
            track = None
            artist = match.group(1).strip()
            title = match.group(2).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 6: "Title" (title only)
        title = name.strip()
        return {
            "track": None,
            "artist": None,
            "title": title if title else None,
            "album": None,
            "comment": comment,
        }

    def read_tags(self, filepath: Path) -> dict[str, any]:
        """Read tags from an audio file"""
        ext = filepath.suffix.lower()
        tags = {
            "filename": filepath.name,
            "track": None,
            "artist": None,
            "title": None,
            "album": None,
            "albumartist": None,
            "genre": None,
            "year": None,
            "artwork": None,
            "compilation": None,
            "label": None,
            "bandcamp_id": None,
            "disc": None,
            "comment": None,
        }

        try:
            if ext == ".mp3":
                audio = MP3(str(filepath), ID3=ID3)
                if audio.tags:
                    # Track number
                    if "TRCK" in audio.tags:
                        track_str = str(audio.tags["TRCK"])
                        tags["track"] = (
                            int(track_str.split("/")[0])
                            if "/" in track_str
                            else int(track_str)
                        )

                    # Disc number
                    if "TPOS" in audio.tags:
                        disc_str = str(audio.tags["TPOS"])
                        tags["disc"] = (
                            int(disc_str.split("/")[0])
                            if "/" in disc_str
                            else int(disc_str)
                        )

                    # Text fields
                    if "TIT2" in audio.tags:
                        tags["title"] = str(audio.tags["TIT2"])
                    if "TPE1" in audio.tags:
                        tags["artist"] = str(audio.tags["TPE1"])
                    if "TALB" in audio.tags:
                        tags["album"] = str(audio.tags["TALB"])
                    if "TPE2" in audio.tags:
                        tags["albumartist"] = str(audio.tags["TPE2"])
                    if "TCON" in audio.tags:
                        tags["genre"] = str(audio.tags["TCON"])
                    if "TDRC" in audio.tags:
                        tags["year"] = int(str(audio.tags["TDRC"]))
                    if "TCMP" in audio.tags:
                        tags["compilation"] = str(audio.tags["TCMP"]) == "1"

                    # Artwork (APIC frames can have different descriptions like "APIC:Cover", "APIC:", etc.)
                    has_artwork = any(
                        key.startswith("APIC:") for key in audio.tags.keys()
                    )
                    if has_artwork:
                        tags["artwork"] = "<embedded>"

                    # Custom tags (TXXX frames)
                    if "TXXX:LABEL" in audio.tags:
                        tags["label"] = str(audio.tags["TXXX:LABEL"])
                    if "TXXX:BANDCAMP_ID" in audio.tags:
                        tags["bandcamp_id"] = str(audio.tags["TXXX:BANDCAMP_ID"])

                    # Comment (COMM frame)
                    if "COMM::eng" in audio.tags:
                        tags["comment"] = str(audio.tags["COMM::eng"])
                    elif "COMM::" in audio.tags:
                        tags["comment"] = str(audio.tags["COMM::"])

            elif ext == ".m4a":
                audio = MP4(str(filepath))
                if audio.tags:
                    # Track number
                    if "\xa9nam" in audio.tags:
                        tags["title"] = audio.tags["\xa9nam"][0]
                    if "\xa9ART" in audio.tags:
                        tags["artist"] = audio.tags["\xa9ART"][0]
                    if "\xa9alb" in audio.tags:
                        tags["album"] = audio.tags["\xa9alb"][0]
                    if "aART" in audio.tags:
                        tags["albumartist"] = audio.tags["aART"][0]
                    if "\xa9gen" in audio.tags:
                        tags["genre"] = audio.tags["\xa9gen"][0]
                    if "\xa9day" in audio.tags:
                        tags["year"] = int(audio.tags["\xa9day"][0])
                    if "trkn" in audio.tags:
                        tags["track"] = audio.tags["trkn"][0][0]
                    if "disk" in audio.tags:
                        tags["disc"] = audio.tags["disk"][0][0]
                    if "cpil" in audio.tags:
                        tags["compilation"] = bool(audio.tags["cpil"][0])

                    # Artwork
                    if "covr" in audio.tags:
                        tags["artwork"] = "<embedded>"

                    # Comment
                    if "\xa9cmt" in audio.tags:
                        tags["comment"] = audio.tags["\xa9cmt"][0]

                    # Custom tags (freeform)
                    if "----:com.apple.iTunes:LABEL" in audio.tags:
                        tags["label"] = audio.tags["----:com.apple.iTunes:LABEL"][
                            0
                        ].decode("utf-8")
                    if "----:com.apple.iTunes:BANDCAMP_ID" in audio.tags:
                        tags["bandcamp_id"] = audio.tags[
                            "----:com.apple.iTunes:BANDCAMP_ID"
                        ][0].decode("utf-8")

        except Exception as e:
            self.log(f"Warning: Could not read tags from {filepath}: {e}")

        # If track, artist, title, album, label, bandcamp_id, or comment is missing, try to parse from filename
        # Or if prefer_filename is True, always parse and use filename values
        if (
            self.prefer_filename
            or tags["track"] is None
            or tags["artist"] is None
            or tags["title"] is None
            or tags["album"] is None
            or tags["label"] is None
            or tags["bandcamp_id"] is None
            or tags["comment"] is None
        ):
            parsed = self.parse_filename(filepath.name)

            if (self.prefer_filename or tags["track"] is None) and parsed.get(
                "track"
            ) is not None:
                tags["track"] = parsed["track"]
            if (self.prefer_filename or tags["artist"] is None) and parsed.get(
                "artist"
            ) is not None:
                tags["artist"] = parsed["artist"]
            if (self.prefer_filename or tags["title"] is None) and parsed.get(
                "title"
            ) is not None:
                tags["title"] = parsed["title"]
            if (self.prefer_filename or tags["album"] is None) and parsed.get(
                "album"
            ) is not None:
                tags["album"] = parsed["album"]
            if (self.prefer_filename or tags["label"] is None) and parsed.get(
                "label"
            ) is not None:
                tags["label"] = parsed["label"]
            if (self.prefer_filename or tags["bandcamp_id"] is None) and parsed.get(
                "bandcamp_id"
            ) is not None:
                tags["bandcamp_id"] = parsed["bandcamp_id"]
            if (self.prefer_filename or tags["comment"] is None) and parsed.get(
                "comment"
            ) is not None:
                tags["comment"] = parsed["comment"]

        return tags

    def _compare_tags(
        self, current: dict[str, any], expected: dict[str, any]
    ) -> dict[str, tuple[any, any]]:
        """
        Compare current tags with expected tags and return differences.
        Returns a dict of {field: (current_value, expected_value)} for fields that differ.
        """
        differences = {}

        # Fields to compare (excluding 'filename' which is not a tag)
        comparable_fields = [
            "track",
            "artist",
            "title",
            "album",
            "albumartist",
            "genre",
            "year",
            "compilation",
            "label",
            "bandcamp_id",
            "artwork",
            "disc",
            "comment",
        ]

        for field in comparable_fields:
            expected_value = expected.get(field)
            current_value = current.get(field)

            # Special handling for artwork
            if field == "artwork":
                # If YAML specifies a file path, we need to check if it matches embedded artwork
                if expected_value and expected_value != "<embedded>":
                    # YAML wants to set artwork from file
                    if current_value != "<embedded>":
                        differences[field] = (current_value, expected_value)
                elif expected_value == "<embedded>":
                    # YAML expects embedded artwork to exist
                    if current_value != "<embedded>":
                        differences[field] = (current_value, expected_value)
                # If expected_value is None, we don't care about artwork
                continue

            # For other fields, only compare if expected value is not None
            # (None means "not specified in YAML, don't modify")
            if expected_value is not None and current_value != expected_value:
                differences[field] = (current_value, expected_value)

        return differences

    def write_tags(self, filepath: Path, tags: dict[str, any]) -> bool:
        """Write tags to an audio file"""
        ext = filepath.suffix.lower()

        # Read current tags to check if update is needed
        current_tags = self.read_tags(filepath)
        differences = self._compare_tags(current_tags, tags)

        if self.dry_run:
            if differences:
                self.log(f"Would update tags for: {filepath}")
            # Don't output anything if tags are already up-to-date
            return True

        # Skip update if no differences
        if not differences:
            return True

        try:
            if ext == ".mp3":
                audio = MP3(str(filepath), ID3=ID3)

                # Create ID3 tag if it doesn't exist
                if audio.tags is None:
                    audio.add_tags()

                # Set tags
                if tags.get("title"):
                    audio.tags.add(TIT2(encoding=3, text=tags["title"]))
                if tags.get("artist"):
                    audio.tags.add(TPE1(encoding=3, text=tags["artist"]))
                if tags.get("album"):
                    audio.tags.add(TALB(encoding=3, text=tags["album"]))
                if tags.get("albumartist"):
                    audio.tags.add(TPE2(encoding=3, text=tags["albumartist"]))
                if tags.get("genre"):
                    audio.tags.add(TCON(encoding=3, text=tags["genre"]))
                if tags.get("year"):
                    audio.tags.add(TDRC(encoding=3, text=str(tags["year"])))
                if tags.get("track"):
                    audio.tags.add(TRCK(encoding=3, text=str(tags["track"])))
                if tags.get("disc"):
                    audio.tags.add(TPOS(encoding=3, text=str(tags["disc"])))
                if tags.get("compilation") is not None:
                    audio.tags.add(
                        TCMP(encoding=3, text="1" if tags["compilation"] else "0")
                    )

                # Custom tags
                if tags.get("label"):
                    audio.tags.add(TXXX(encoding=3, desc="LABEL", text=tags["label"]))
                if tags.get("bandcamp_id"):
                    audio.tags.add(
                        TXXX(encoding=3, desc="BANDCAMP_ID", text=tags["bandcamp_id"])
                    )

                # Comment
                if tags.get("comment"):
                    audio.tags.add(
                        COMM(encoding=3, lang="eng", desc="", text=tags["comment"])
                    )

                # Artwork
                if tags.get("artwork") and tags["artwork"] != "<embedded>":
                    artwork_path = Path(tags["artwork"])
                    if artwork_path.exists():
                        with open(artwork_path, "rb") as f:
                            audio.tags.add(
                                APIC(
                                    encoding=3,
                                    mime=(
                                        "image/jpeg"
                                        if artwork_path.suffix.lower()
                                        in [".jpg", ".jpeg"]
                                        else "image/png"
                                    ),
                                    type=3,  # Cover (front)
                                    desc="Cover",
                                    data=f.read(),
                                )
                            )

                audio.save()

            elif ext == ".m4a":
                audio = MP4(str(filepath))

                # Set tags
                if tags.get("title"):
                    audio.tags["\xa9nam"] = tags["title"]
                if tags.get("artist"):
                    audio.tags["\xa9ART"] = tags["artist"]
                if tags.get("album"):
                    audio.tags["\xa9alb"] = tags["album"]
                if tags.get("albumartist"):
                    audio.tags["aART"] = tags["albumartist"]
                if tags.get("genre"):
                    audio.tags["\xa9gen"] = tags["genre"]
                if tags.get("year"):
                    audio.tags["\xa9day"] = str(tags["year"])
                if tags.get("track"):
                    audio.tags["trkn"] = [(tags["track"], 0)]
                if tags.get("disc"):
                    audio.tags["disk"] = [(tags["disc"], 0)]
                if tags.get("compilation") is not None:
                    audio.tags["cpil"] = [tags["compilation"]]

                # Comment
                if tags.get("comment"):
                    audio.tags["\xa9cmt"] = tags["comment"]

                # Custom tags
                if tags.get("label"):
                    audio.tags["----:com.apple.iTunes:LABEL"] = tags["label"].encode(
                        "utf-8"
                    )
                if tags.get("bandcamp_id"):
                    audio.tags["----:com.apple.iTunes:BANDCAMP_ID"] = tags[
                        "bandcamp_id"
                    ].encode("utf-8")

                # Artwork
                if tags.get("artwork") and tags["artwork"] != "<embedded>":
                    artwork_path = Path(tags["artwork"])
                    if artwork_path.exists():
                        with open(artwork_path, "rb") as f:
                            cover_data = f.read()
                            if artwork_path.suffix.lower() == ".png":
                                audio.tags["covr"] = [
                                    MP4Cover(
                                        cover_data, imageformat=MP4Cover.FORMAT_PNG
                                    )
                                ]
                            else:
                                audio.tags["covr"] = [
                                    MP4Cover(
                                        cover_data, imageformat=MP4Cover.FORMAT_JPEG
                                    )
                                ]

                audio.save()

            self.log(f"Updated tags for: {filepath}")
            return True

        except Exception as e:
            self.log(f"Error: Could not write tags to {filepath}: {e}")
            return False

    def sanitize_filename(self, name: str) -> str:
        """Sanitize filename by removing invalid characters"""
        invalid_chars = '<>:"/\\|?*'
        for char in invalid_chars:
            name = name.replace(char, "_")
        return name

    def generate_filename(
        self, tags: dict[str, any], max_track: int | None = None
    ) -> str:
        """Generate filename from tags

        Args:
            tags: Dictionary of tag values
            max_track: Maximum track number (for padding). If None, uses 2 digits minimum.
        """
        track = tags.get("track", "")
        disc = tags.get("disc", "")
        artist = tags.get("artist", "")
        title = tags.get("title", "Unknown Title")

        # Get original extension
        original_filename = tags.get("filename", ".mp3")
        ext = Path(original_filename).suffix

        # Determine padding width based on max_track
        # Always use at least 2 digits, even if max_track is single digit
        if max_track is not None and max_track > 0:
            padding = max(2, len(str(max_track)))
        else:
            padding = 2  # Default to 2 digits

        # Build track prefix with optional disc number
        # Disc number is always 2 digits: 01-01, 02-03, etc.
        track_prefix = ""
        if track:
            if disc:
                track_prefix = f"{disc:02d}-{track:0{padding}d}"
            else:
                track_prefix = f"{track:0{padding}d}"

        # Build filename based on available metadata
        # Hyphens use 1 space before and after, except track-only uses 2 spaces before hyphen
        if track_prefix and artist:
            # Format: 01-01 Artist - Title.mp3 (with disc) or 01 Artist - Title.mp3 (without disc)
            filename = f"{track_prefix} {artist} - {title}{ext}"
        elif track_prefix:
            # Format: 01-01  - Title.mp3 (no artist, 2 spaces before hyphen)
            filename = f"{track_prefix}  - {title}{ext}"
        elif artist:
            # Format: Artist - Title.mp3 (no track)
            filename = f"{artist} - {title}{ext}"
        else:
            # Format: Title.mp3 (no track, no artist)
            filename = f"{title}{ext}"

        return self.sanitize_filename(filename)

    def rename_file(self, old_path: Path, new_filename: str) -> Path | None:
        """Rename a file"""
        new_path = old_path.parent / new_filename

        if old_path == new_path:
            return old_path

        if self.dry_run:
            self.log(f"Would rename: {old_path.name} -> {new_filename}")
            return new_path

        try:
            old_path.rename(new_path)
            self.log(f"Renamed: {old_path.name} -> {new_filename}")
            return new_path
        except Exception as e:
            self.log(f"Error: Could not rename {old_path}: {e}")
            return None

    def compare_tags(
        self, current: dict, yaml_data: dict, filepath: Path | None = None
    ) -> dict:
        """Compare current tags with YAML data and return differences

        For artwork, compares actual file contents if filepath is provided
        """
        diff = {}
        all_keys = set(current.keys()) | set(yaml_data.keys())

        for key in all_keys:
            current_val = current.get(key)
            yaml_val = yaml_data.get(key)

            # Special handling for artwork comparison
            if key == "artwork" and filepath:
                # If current has embedded artwork and YAML specifies a file
                if (
                    current_val == "<embedded>"
                    and yaml_val
                    and yaml_val != "<embedded>"
                ):
                    # Compare actual file contents
                    if self.compare_artwork(filepath, yaml_val):
                        # Artwork is the same, skip diff
                        continue
                # If both are "<embedded>", they're the same
                elif current_val == "<embedded>" and yaml_val == "<embedded>":
                    continue

            if current_val != yaml_val:
                diff[key] = {"current": current_val, "yaml": yaml_val}

        return diff

    def show_diff(self, yaml_file: str = "tagger.yaml"):
        """Show differences between current state and YAML file"""
        if not os.path.exists(yaml_file):
            self.log(f"Error: {yaml_file} not found")
            return

        # First, convert any .aac files to .m4a
        self.find_and_convert_aac_files()

        # Load YAML file
        with open(yaml_file, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)

        # Validate YAML structure
        try:
            config = TaggerConfig(**data)
        except ValidationError as e:
            self.log(f"Error: YAML validation failed for {yaml_file}:")
            for error in e.errors():
                field = " -> ".join(str(x) for x in error["loc"])
                self.log(f"  {field}: {error['msg']}")
            return

        # Get defaults from YAML
        defaults = (
            config.defaults.model_dump(exclude_none=True, mode="python")
            if config.defaults
            else {}
        )

        # Get current files
        files = self.find_audio_files()
        current_files = {f.name: f for f in files}

        # Get YAML files
        yaml_files = {f.filename: f for f in config.files}

        # Find files only in YAML (deleted files)
        deleted_files = set(yaml_files.keys()) - set(current_files.keys())

        # Find files only in current directory (new files)
        new_files = set(current_files.keys()) - set(yaml_files.keys())

        # Find common files (potentially modified)
        common_files = set(current_files.keys()) & set(yaml_files.keys())

        has_changes = False

        # Show deleted files
        if deleted_files:
            has_changes = True
            print("\n" + self.color("=" * 60, "dim"))
            print(
                self.color(
                    "DELETED FILES (in YAML but not in directory):", "red", "bold"
                )
            )
            print(self.color("=" * 60, "dim"))
            for filename in sorted(deleted_files):
                print(f"  {self.color('-', 'red')} {self.color(filename, 'red')}")

        # Show new files
        if new_files:
            has_changes = True
            print("\n" + self.color("=" * 60, "dim"))
            print(
                self.color("NEW FILES (in directory but not in YAML):", "green", "bold")
            )
            print(self.color("=" * 60, "dim"))
            for filename in sorted(new_files):
                filepath = current_files[filename]
                current_tags = self.read_tags(filepath)
                print(f"\n  {self.color(filename, 'green', 'bold')}:")
                for key, value in current_tags.items():
                    if key != "filename" and value is not None:
                        print(f"    {self.color(key, 'cyan')}: {value}")

        # Show modified files
        modified_files = []
        for filename in sorted(common_files):
            filepath = current_files[filename]
            current_tags = self.read_tags(filepath)

            # Get YAML data for this file
            yaml_file_data = next(
                f.model_dump(exclude_none=True, mode="python")
                for f in config.files
                if f.filename == filename
            )

            # Merge defaults with file-specific data
            yaml_tags = defaults | yaml_file_data

            # Compare tags (pass filepath for artwork comparison)
            diff = self.compare_tags(current_tags, yaml_tags, filepath)

            if diff:
                modified_files.append((filename, diff))

        if modified_files:
            has_changes = True
            print("\n" + self.color("=" * 60, "dim"))
            print(
                self.color(
                    "MODIFIED FILES (differences between current and YAML):",
                    "yellow",
                    "bold",
                )
            )
            print(self.color("=" * 60, "dim"))
            for filename, diff in modified_files:
                print(f"\n  {self.color(filename, 'yellow', 'bold')}:")
                for key, values in diff.items():
                    if key == "filename":
                        continue
                    current_val = values["current"]
                    yaml_val = values["yaml"]
                    print(f"    {self.color(key, 'cyan')}:")
                    print(
                        f"      {self.color('current:', 'green')} {self.color(str(current_val), 'green')}"
                    )
                    print(
                        f"      {self.color('yaml:   ', 'red')} {self.color(str(yaml_val), 'red')}"
                    )

        if not has_changes:
            print("\n" + self.color("=" * 60, "dim"))
            print(self.color("NO CHANGES DETECTED", "green", "bold"))
            print(self.color("=" * 60, "dim"))
            print(
                f"\n{self.color('', 'green')} Current directory state matches {self.color(yaml_file, 'cyan')}"
            )

    def generate_yaml(self, output_file: str = "tagger.yaml", interactive: bool = True):
        """Generate YAML file from current directory audio files

        Args:
            output_file: Output YAML filename
            interactive: If True, prompt user for preferences when conflicts exist
        """
        # First, convert any .aac files to .m4a
        self.find_and_convert_aac_files()

        files = self.find_audio_files()

        if not files:
            self.log("No audio files found in current directory")
            return

        self.log(f"Found {len(files)} audio file(s)")

        # Check if any files have both embedded tags and parseable filenames
        # If so, ask user which to prefer
        if interactive and not self.dry_run:
            has_conflict = False
            for filepath in files:
                # Temporarily read tags without filename parsing
                old_prefer = self.prefer_filename
                self.prefer_filename = False
                tags_only = self.read_tags(filepath)
                self.prefer_filename = old_prefer

                parsed = self.parse_filename(filepath.name)

                # Check if both have artist and title
                if (
                    tags_only.get("artist")
                    and parsed.get("artist")
                    and tags_only.get("artist") != parsed.get("artist")
                ) or (
                    tags_only.get("title")
                    and parsed.get("title")
                    and tags_only.get("title") != parsed.get("title")
                ):
                    has_conflict = True
                    break

            if has_conflict:
                print(
                    "\n"
                    + self.color(
                        "Some files have different information in tags vs. filenames.",
                        "yellow",
                    )
                )
                print(
                    "Which source should be preferred when generating the YAML file?\n"
                )
                print("  1. Embedded tags (default)")
                print("  2. Filenames")
                print()

                while True:
                    choice = input("Enter your choice (1 or 2) [1]: ").strip()
                    if choice == "" or choice == "1":
                        self.prefer_filename = False
                        break
                    elif choice == "2":
                        self.prefer_filename = True
                        break
                    else:
                        print("Invalid choice. Please enter 1 or 2.")

        # Read tags from all files
        entries = []
        artwork_downloads = {}  # Track thumbnails to download (video_id: path)
        bandcamp_artwork_downloads = (
            {}
        )  # Track Bandcamp artwork to download (url: path)

        for filepath in files:
            tags = self.read_tags(filepath)

            # Check for YouTube URL in comment field
            comment = tags.get("comment")
            if comment and "youtube.com" in comment:
                video_id = self.extract_youtube_video_id(comment)
                if video_id:
                    thumbnail_path = self.get_thumbnail_path_for_file(
                        filepath, video_id
                    )

                    # Skip if thumbnail already exists
                    if not thumbnail_path.exists():
                        artwork_downloads[video_id] = thumbnail_path

                    # Set artwork if not already present
                    if not tags.get("artwork"):
                        tags["artwork"] = str(thumbnail_path.name)  # Relative path

            # Check for Bandcamp URL in comment field
            if comment and "bandcamp.com" in comment:
                url_info = self.extract_bandcamp_url_info(comment)
                if url_info:
                    artwork_path = self.get_bandcamp_artwork_path_for_file(
                        filepath, url_info
                    )

                    # Skip if artwork already exists
                    if not artwork_path.exists():
                        # Use full URL as key for deduplication
                        bandcamp_artwork_downloads[comment] = artwork_path

                    # Set artwork if not already present
                    if not tags.get("artwork"):
                        tags["artwork"] = str(artwork_path.name)  # Relative path

            # Remove None values
            entry = {k: v for k, v in tags.items() if v is not None}
            entries.append(entry)

        # Download thumbnails (execute mode only)
        if not self.dry_run and artwork_downloads:
            self.log(f"Downloading {len(artwork_downloads)} YouTube thumbnail(s)...")

            # Determine crop setting
            crop_choice = None
            if self.thumbnail_crop == "square":
                crop_choice = True
            elif self.thumbnail_crop == "none":
                crop_choice = False
            # else: auto mode, will ask for each thumbnail

            for idx, (video_id, path) in enumerate(artwork_downloads.items(), 1):
                print(
                    f"  [{idx}/{len(artwork_downloads)}] {video_id}...",
                    end="",
                    flush=True,
                )

                # Download thumbnail first
                if self.download_youtube_thumbnail(video_id, path, crop=False):
                    print("  Downloaded")

                    # Determine whether to crop this thumbnail
                    should_crop = crop_choice
                    if should_crop is None:  # auto mode
                        should_crop = self.ask_thumbnail_crop(path)

                    # Apply crop if needed
                    if should_crop:
                        try:
                            from PIL import Image

                            img = Image.open(path)
                            width, height = img.size

                            # Only crop if not already square
                            if width != height:
                                if width > height:
                                    left = (width - height) // 2
                                    img_cropped = img.crop(
                                        (left, 0, left + height, height)
                                    )
                                else:
                                    top = (height - width) // 2
                                    img_cropped = img.crop((0, top, width, top + width))

                                img_cropped.save(path, "JPEG", quality=95)
                                print(f"     Cropped to square")
                        except Exception as e:
                            self.log(f"    Warning: Failed to crop: {e}")
                else:
                    print("  Failed")

        # Download Bandcamp artwork (execute mode only)
        if not self.dry_run and bandcamp_artwork_downloads:
            self.log(
                f"Downloading {len(bandcamp_artwork_downloads)} Bandcamp artwork(s)..."
            )

            # Determine crop setting (reuse same logic as YouTube)
            crop_choice = None
            if self.thumbnail_crop == "square":
                crop_choice = True
            elif self.thumbnail_crop == "none":
                crop_choice = False
            # else: auto mode, will ask for each artwork

            for idx, (url, path) in enumerate(bandcamp_artwork_downloads.items(), 1):
                print(
                    f"  [{idx}/{len(bandcamp_artwork_downloads)}] {url}...",
                    end="",
                    flush=True,
                )

                # Download artwork first
                if self.download_bandcamp_artwork(url, path, crop=False):
                    print("  Downloaded")

                    # Determine whether to crop
                    should_crop = crop_choice
                    if should_crop is None:  # auto mode
                        should_crop = self.ask_thumbnail_crop(
                            path
                        )  # Reuse existing function

                    # Apply crop if needed (same logic as YouTube)
                    if should_crop:
                        try:
                            from PIL import Image

                            img = Image.open(path)
                            width, height = img.size

                            # Only crop if not already square
                            if width != height:
                                if width > height:
                                    left = (width - height) // 2
                                    img_cropped = img.crop(
                                        (left, 0, left + height, height)
                                    )
                                else:
                                    top = (height - width) // 2
                                    img_cropped = img.crop((0, top, width, top + width))

                                img_cropped.save(path, "JPEG", quality=95)
                                print(f"     Cropped to square")
                        except Exception as e:
                            self.log(f"    Warning: Failed to crop: {e}")
                else:
                    print("  Failed")

        # Extract common fields to defaults
        common_fields = [
            "album",
            "albumartist",
            "genre",
            "year",
            "artwork",
            "compilation",
            "label",
            "bandcamp_id",
            "disc",
            "comment",
        ]
        defaults = {}

        if len(entries) > 1:  # Only extract defaults if there are multiple files
            for field in common_fields:
                # Get all values for this field (excluding None)
                values = [entry.get(field) for entry in entries if field in entry]

                # If all files have the same non-None value, move to defaults
                if (
                    values
                    and len(values) == len(entries)
                    and len(set(str(v) for v in values)) == 1
                ):
                    defaults[field] = values[0]

            # Remove common fields from individual entries
            if defaults:
                for entry in entries:
                    for field in defaults:
                        entry.pop(field, None)

        # Sort entries by track number (entries without track number go last)
        def get_track_sort_key(entry):
            track = entry.get("track")
            if track is None:
                # Check if track is in defaults
                track = defaults.get("track")
            # Return tuple: (has_track, track_number)
            # Entries without track go last (True > False)
            if track is None:
                return (True, 0)
            return (False, track)

        entries_sorted = sorted(entries, key=get_track_sort_key)

        # Create YAML structure
        yaml_data = {}
        if defaults:
            yaml_data["defaults"] = defaults
        yaml_data["files"] = entries_sorted

        # Validate YAML structure
        try:
            config = TaggerConfig(**yaml_data)
            # Convert back to dict for YAML serialization
            yaml_data = config.model_dump(exclude_none=True, mode="python")
        except ValidationError as e:
            self.log(f"Error: Generated YAML validation failed:")
            for error in e.errors():
                field = " -> ".join(str(x) for x in error["loc"])
                self.log(f"  {field}: {error['msg']}")
            sys.exit(1)

        # Generate YAML string with schema comment
        schema_url = "https://raw.githubusercontent.com/delphinus/homebrew-tagger/main/tagger.schema.json"
        schema_comment = f"# yaml-language-server: $schema={schema_url}\n\n"

        yaml_str = yaml.dump(
            yaml_data, allow_unicode=True, default_flow_style=False, sort_keys=False
        )

        if self.dry_run:
            # Show artwork download summary if any
            total_downloads = len(artwork_downloads) + len(bandcamp_artwork_downloads)
            if total_downloads > 0:
                self.log("")
                self.log("Artwork Download Summary:")
                self.log("-" * 60)

                if artwork_downloads:
                    self.log(f"YouTube Thumbnails: {len(artwork_downloads)} file(s)")
                    for idx, (video_id, path) in enumerate(
                        artwork_downloads.items(), 1
                    ):
                        self.log(f"  [{idx}] {video_id} -> {path.name}")

                if bandcamp_artwork_downloads:
                    self.log(
                        f"Bandcamp Artwork: {len(bandcamp_artwork_downloads)} file(s)"
                    )
                    for idx, (url, path) in enumerate(
                        bandcamp_artwork_downloads.items(), 1
                    ):
                        # Extract readable display name from URL
                        url_info = self.extract_bandcamp_url_info(url)
                        if url_info:
                            display_name = f"{url_info['label_slug']}/{url_info['type']}/{url_info['slug']}"
                        else:
                            display_name = url[:50] + "..." if len(url) > 50 else url
                        self.log(f"  [{idx}] {display_name} -> {path.name}")

                self.log("-" * 60)
                self.log(
                    f"Total: {total_downloads} artwork file(s) would be downloaded with -e flag"
                )
                self.log("")

            self.log(f"Would create {output_file} with content:")
            print("\n" + "=" * 60)
            print(schema_comment + yaml_str)
            print("=" * 60)
        else:
            with open(output_file, "w", encoding="utf-8") as f:
                f.write(schema_comment)
                f.write(yaml_str)
            self.log(f"Created {output_file}")

    def apply_yaml(self, yaml_file: str):
        """Apply tags and filenames from YAML file"""
        # First, convert any .aac files to .m4a
        self.find_and_convert_aac_files()

        if not os.path.exists(yaml_file):
            self.log(f"Error: YAML file not found: {yaml_file}")
            sys.exit(1)

        # Load YAML
        with open(yaml_file, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)

        # Validate YAML structure
        try:
            config = TaggerConfig(**data)
            self.log("YAML validation successful")
        except ValidationError as e:
            self.log(f"Error: YAML validation failed for {yaml_file}:")
            for error in e.errors():
                field = " -> ".join(str(x) for x in error["loc"])
                self.log(f"  {field}: {error['msg']}")
            self.log("\nCommon issues:")
            self.log(
                "  - Check for typos in field names (e.g., 'default' should be 'defaults')"
            )
            self.log("  - Ensure all required fields are present")
            self.log(
                "  - Verify data types (e.g., year should be a number, not a string)"
            )
            sys.exit(1)

        # Get defaults if present
        defaults = (
            config.defaults.model_dump(exclude_none=True, mode="python")
            if config.defaults
            else {}
        )

        files_data = [
            f.model_dump(exclude_none=True, mode="python") for f in config.files
        ]
        self.log(f"Processing {len(files_data)} file(s) from {yaml_file}")

        # Track Bandcamp artwork to download (url: path)
        bandcamp_artwork_downloads = {}

        # Calculate maximum track number for padding
        max_track = 0
        for file_data in files_data:
            merged_data = defaults | file_data
            track = merged_data.get("track")
            if track is not None and track > max_track:
                max_track = track

        for file_data in files_data:
            if "filename" not in file_data:
                self.log("Warning: Skipping entry without 'filename'")
                continue

            original_filename = file_data["filename"]
            filepath = Path(original_filename)

            if not filepath.exists():
                self.log(f"Warning: File not found: {original_filename}")
                continue

            # Merge defaults with file-specific data (file-specific takes priority)
            merged_data = defaults | file_data

            # Check for Bandcamp URL in comment field
            comment = merged_data.get("comment")
            if comment and "bandcamp.com" in comment:
                url_info = self.extract_bandcamp_url_info(comment)
                if url_info:
                    artwork_path = self.get_bandcamp_artwork_path_for_file(
                        filepath, url_info
                    )

                    # Skip if artwork already exists
                    if not artwork_path.exists():
                        # Use full URL as key for deduplication
                        bandcamp_artwork_downloads[comment] = artwork_path

                    # Set artwork if not already present
                    if not merged_data.get("artwork"):
                        merged_data["artwork"] = str(artwork_path.name)  # Relative path

            # Write tags
            self.write_tags(filepath, merged_data)

            # Generate new filename with proper track padding
            new_filename = self.generate_filename(
                merged_data, max_track if max_track > 0 else None
            )

            # Rename file if needed
            new_path = self.rename_file(filepath, new_filename)

            # Update YAML entry with new filename for future reference
            if new_path and not self.dry_run:
                file_data["filename"] = new_path.name

        # Download Bandcamp artwork (execute mode only)
        if not self.dry_run and bandcamp_artwork_downloads:
            self.log(
                f"Downloading {len(bandcamp_artwork_downloads)} Bandcamp artwork(s)..."
            )

            # Determine crop setting (reuse same logic as YouTube)
            crop_choice = None
            if self.thumbnail_crop == "square":
                crop_choice = True
            elif self.thumbnail_crop == "none":
                crop_choice = False
            # else: auto mode, will ask for each artwork

            for idx, (url, path) in enumerate(bandcamp_artwork_downloads.items(), 1):
                print(
                    f"  [{idx}/{len(bandcamp_artwork_downloads)}] {url}...",
                    end="",
                    flush=True,
                )

                # Download artwork first
                if self.download_bandcamp_artwork(url, path, crop=False):
                    print("  Downloaded")

                    # Determine whether to crop
                    should_crop = crop_choice
                    if should_crop is None:
                        # Auto mode: ask user
                        while True:
                            print(
                                "    Crop to square? (y/n/a=always/n=never): ",
                                end="",
                                flush=True,
                            )
                            choice = input().strip().lower()
                            if choice in ["y", "yes"]:
                                should_crop = True
                                break
                            elif choice in ["n", "no"]:
                                should_crop = False
                                break
                            elif choice == "a":
                                should_crop = True
                                crop_choice = True  # Remember for next files
                                break
                            elif choice == "v":
                                should_crop = False
                                crop_choice = False  # Remember for next files
                                break
                            else:
                                print("    Invalid choice. Please enter y/n/a/v.")

                    # Crop if requested
                    if should_crop:
                        try:
                            from PIL import Image

                            img = Image.open(path)
                            width, height = img.size

                            if width != height:
                                # Crop to center square
                                if width > height:
                                    left = (width - height) // 2
                                    img_cropped = img.crop(
                                        (left, 0, left + height, height)
                                    )
                                else:
                                    top = (height - width) // 2
                                    img_cropped = img.crop((0, top, width, top + width))

                                img_cropped.save(path, "JPEG", quality=95)
                                print(f"     Cropped to square")
                        except Exception as e:
                            self.log(f"    Warning: Failed to crop: {e}")
                else:
                    print("  Failed")

        # Show artwork download summary in dry-run mode
        if self.dry_run and bandcamp_artwork_downloads:
            self.log("")
            self.log("Artwork Download Summary:")
            self.log("-" * 60)
            self.log(f"Bandcamp Artwork: {len(bandcamp_artwork_downloads)} file(s)")
            for idx, (url, path) in enumerate(bandcamp_artwork_downloads.items(), 1):
                # Extract readable display name from URL
                url_info = self.extract_bandcamp_url_info(url)
                if url_info:
                    display_name = f"{url_info['label_slug']}/{url_info['type']}/{url_info['slug']}"
                else:
                    display_name = url[:50] + "..." if len(url) > 50 else url
                self.log(f"  [{idx}] {display_name} -> {path.name}")
            self.log("-" * 60)
            self.log(
                f"Total: {len(bandcamp_artwork_downloads)} artwork file(s) would be downloaded with -e flag"
            )
            self.log("")

        # Update YAML file with new filenames
        if not self.dry_run:
            # Sort files by track number (files without track number go last)
            def get_track_sort_key(file_data):
                merged = defaults | file_data
                track = merged.get("track")
                # Return tuple: (has_track, track_number)
                # Files without track go last (True > False)
                if track is None:
                    return (True, 0)
                return (False, track)

            files_data_sorted = sorted(files_data, key=get_track_sort_key)

            # Update the files list in data with the sorted files_data
            data["files"] = files_data_sorted
            with open(yaml_file, "w", encoding="utf-8") as f:
                yaml.dump(
                    data,
                    f,
                    allow_unicode=True,
                    default_flow_style=False,
                    sort_keys=False,
                )
            self.log(f"Updated {yaml_file} with new filenames")


def main():
    parser = argparse.ArgumentParser(
        description="Manage audio file tags and filenames using mutagen",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Show diff if tagger.yaml exists, otherwise generate YAML (dry-run)
  tagger

  # Generate YAML and save it (even if tagger.yaml exists)
  tagger --execute

  # Apply tags from YAML (dry-run)
  tagger tagger.yaml

  # Apply tags from YAML and execute
  tagger --execute tagger.yaml

Note:
  When running 'tagger' without arguments, if tagger.yaml exists in the current
  directory, it will show differences between the current state and the YAML file.
  This helps you see what has changed before updating the YAML or applying tags.
        """,
    )

    parser.add_argument(
        "yaml_file",
        nargs="?",
        help="YAML file with tag information (if not provided, generates YAML from current directory)",
    )

    parser.add_argument(
        "-e",
        "--execute",
        action="store_true",
        help="Execute changes (default is dry-run mode)",
    )

    parser.add_argument(
        "-o",
        "--output",
        default="tagger.yaml",
        help="Output YAML file name when generating (default: tagger.yaml)",
    )

    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
    )

    parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable colored output",
    )

    parser.add_argument(
        "--prefer-filename",
        action="store_true",
        help="Prefer metadata from filenames over embedded tags when generating YAML (non-interactive mode)",
    )

    parser.add_argument(
        "--thumbnail-crop",
        choices=["auto", "square", "none"],
        default="auto",
        help="YouTube thumbnail cropping: 'auto' (ask for each), 'square' (crop to square), 'none' (keep original) (default: auto)",
    )

    args = parser.parse_args()

    # Regular tagger mode
    tagger = Tagger(
        execute=args.execute,
        no_color=args.no_color,
        prefer_filename=args.prefer_filename,
        thumbnail_crop=args.thumbnail_crop,
    )

    if args.yaml_file:
        # Apply mode
        tagger.apply_yaml(args.yaml_file)
    else:
        # Generate/Diff mode
        # If tagger.yaml exists in current directory, show diff instead of generating
        if os.path.exists("tagger.yaml") and not args.execute:
            tagger.show_diff("tagger.yaml")
        else:
            # If --prefer-filename is set, skip interactive mode
            interactive = not args.prefer_filename
            tagger.generate_yaml(args.output, interactive=interactive)


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
"""
Tagger - Audio file tag and filename manager using mutagen

This script manages tags and filenames for .mp3 and .m4a files.
It can also convert .aac files to .m4a format (lossless container conversion).
"""

__version__ = "1.17.0"

import argparse
import hashlib
import os
import re
import shutil
import subprocess
import sys
from pathlib import Path

import yaml

try:
    from mutagen.id3 import (
        APIC,
        COMM,
        ID3,
        TALB,
        TCMP,
        TCON,
        TDRC,
        TIT2,
        TPE1,
        TPE2,
        TPOS,
        TRCK,
        TXXX,
    )
    from mutagen.mp3 import MP3
    from mutagen.mp4 import MP4, MP4Cover
except ImportError:
    print(
        "Error: mutagen is not installed. Please install it with: pip install mutagen",
        file=sys.stderr,
    )
    sys.exit(1)

try:
    from pydantic import BaseModel, Field, ValidationError, field_validator
except ImportError:
    print(
        "Error: pydantic is not installed. Please install it with: pip install pydantic",
        file=sys.stderr,
    )
    sys.exit(1)


# Pydantic models for YAML schema validation
class Defaults(BaseModel):
    """Default values applied to all files"""

    model_config = {"extra": "forbid"}

    album: str | None = None
    albumartist: str | None = None
    genre: str | None = None
    year: int | None = None
    artwork: str | None = None
    compilation: bool | None = None
    label: str | None = None
    bandcamp_id: str | None = None
    disc: int | None = None
    comment: str | None = None

    @field_validator("year")
    @classmethod
    def validate_year(cls, v: int | None) -> int | None:
        """Validate year is reasonable"""
        if v is not None and (v < 1900 or v > 2100):
            raise ValueError("Year must be between 1900 and 2100")
        return v

    @field_validator("disc")
    @classmethod
    def validate_disc(cls, v: int | None) -> int | None:
        """Validate disc number is positive"""
        if v is not None and v < 1:
            raise ValueError("Disc number must be positive")
        return v


class FileEntry(BaseModel):
    """Schema for a single file entry in the YAML"""

    model_config = {"extra": "forbid"}

    filename: str = Field(..., description="Original filename")
    track: int | None = None
    artist: str | None = None
    title: str | None = None
    album: str | None = None
    albumartist: str | None = None
    genre: str | None = None
    year: int | None = None
    artwork: str | None = None
    compilation: bool | None = None
    label: str | None = None
    bandcamp_id: str | None = None
    disc: int | None = None
    comment: str | None = None

    @field_validator("track")
    @classmethod
    def validate_track(cls, v: int | None) -> int | None:
        """Validate track number is positive"""
        if v is not None and v < 1:
            raise ValueError("Track number must be positive")
        return v

    @field_validator("year")
    @classmethod
    def validate_year(cls, v: int | None) -> int | None:
        """Validate year is reasonable"""
        if v is not None and (v < 1900 or v > 2100):
            raise ValueError("Year must be between 1900 and 2100")
        return v

    @field_validator("disc")
    @classmethod
    def validate_disc(cls, v: int | None) -> int | None:
        """Validate disc number is positive"""
        if v is not None and v < 1:
            raise ValueError("Disc number must be positive")
        return v


class TaggerConfig(BaseModel):
    """Schema for the complete YAML configuration"""

    model_config = {"extra": "forbid"}

    defaults: Defaults | None = None
    files: list[FileEntry] = Field(..., min_length=1, description="List of audio files")

    @field_validator("files")
    @classmethod
    def validate_files_not_empty(cls, v: list[FileEntry]) -> list[FileEntry]:
        """Ensure files list is not empty"""
        if not v:
            raise ValueError("Files list cannot be empty")
        return v


class Tagger:
    """Main class for managing audio file tags and filenames"""

    SUPPORTED_EXTENSIONS = {".mp3", ".m4a"}

    # ANSI color codes
    COLORS = {
        "reset": "\033[0m",
        "red": "\033[91m",
        "green": "\033[92m",
        "yellow": "\033[93m",
        "blue": "\033[94m",
        "magenta": "\033[95m",
        "cyan": "\033[96m",
        "white": "\033[97m",
        "bold": "\033[1m",
        "dim": "\033[2m",
    }

    def __init__(
        self,
        execute: bool = False,
        no_color: bool = False,
        prefer_filename: bool = False,
    ):
        self.execute = execute
        self.dry_run = not execute
        self.no_color = no_color or not sys.stdout.isatty()
        self.prefer_filename = prefer_filename

    def color(self, text: str, *colors: str) -> str:
        """Apply color to text"""
        if self.no_color:
            return text
        color_codes = "".join(self.COLORS.get(c, "") for c in colors)
        return f"{color_codes}{text}{self.COLORS['reset']}"

    def log(self, message: str):
        """Print log message"""
        prefix = "[DRY-RUN] " if self.dry_run else ""
        print(f"{prefix}{message}")

    def get_artwork_hash(self, data: bytes) -> str:
        """Calculate SHA256 hash of artwork data"""
        return hashlib.sha256(data).hexdigest()

    def get_embedded_artwork(self, filepath: Path) -> bytes | None:
        """Extract embedded artwork from audio file"""
        ext = filepath.suffix.lower()

        try:
            if ext == ".mp3":
                audio = MP3(str(filepath), ID3=ID3)
                if audio.tags and "APIC:" in audio.tags:
                    return audio.tags["APIC:"].data
            elif ext == ".m4a":
                audio = MP4(str(filepath))
                if audio.tags and "covr" in audio.tags:
                    return bytes(audio.tags["covr"][0])
        except Exception:
            pass

        return None

    def compare_artwork(self, filepath: Path, artwork_path: str | None) -> bool:
        """Compare embedded artwork with external file

        Returns True if they are the same, False otherwise
        """
        if not artwork_path or artwork_path == "<embedded>":
            # Can't compare if no external file specified
            return False

        # Get embedded artwork
        embedded_data = self.get_embedded_artwork(filepath)
        if not embedded_data:
            # No embedded artwork
            return False

        # Get external artwork file
        external_path = Path(artwork_path)
        if not external_path.exists():
            # External file doesn't exist
            return False

        try:
            with open(external_path, "rb") as f:
                external_data = f.read()
        except Exception:
            return False

        # Compare hashes
        embedded_hash = self.get_artwork_hash(embedded_data)
        external_hash = self.get_artwork_hash(external_data)

        return embedded_hash == external_hash

    def find_audio_files(self, directory: str = ".") -> list[Path]:
        """Find all supported audio files in the directory"""
        path = Path(directory)
        files = []
        for ext in self.SUPPORTED_EXTENSIONS:
            files.extend(path.glob(f"*{ext}"))
        return sorted(files)

    def check_ffmpeg(self) -> bool:
        """Check if ffmpeg is available"""
        return shutil.which("ffmpeg") is not None

    def convert_aac_to_m4a(self, aac_file: Path) -> Path | None:
        """Convert AAC file to M4A format without re-encoding (lossless container conversion)"""
        if not self.check_ffmpeg():
            self.log("Warning: ffmpeg not found. Cannot convert .aac files to .m4a")
            return None

        m4a_file = aac_file.with_suffix(".m4a")

        if self.dry_run:
            self.log(f"Would convert: {aac_file.name} -> {m4a_file.name}")
            return m4a_file

        try:
            # Convert container without re-encoding (lossless)
            subprocess.run(
                ["ffmpeg", "-i", str(aac_file), "-c", "copy", "-y", str(m4a_file)],
                check=True,
                capture_output=True,
                text=True,
            )
            self.log(f"Converted: {aac_file.name} -> {m4a_file.name}")

            # Remove original .aac file after successful conversion
            aac_file.unlink()
            self.log(f"Removed original: {aac_file.name}")

            return m4a_file
        except subprocess.CalledProcessError as e:
            self.log(f"Error: Failed to convert {aac_file}: {e.stderr}")
            return None
        except Exception as e:
            self.log(f"Error: Could not convert {aac_file}: {e}")
            return None

    def find_and_convert_aac_files(self, directory: str = ".") -> list[Path]:
        """Find all .aac files and convert them to .m4a"""
        path = Path(directory)
        aac_files = list(path.glob("*.aac"))

        if not aac_files:
            return []

        self.log(f"Found {len(aac_files)} .aac file(s) to convert")

        converted_files = []
        for aac_file in aac_files:
            m4a_file = self.convert_aac_to_m4a(aac_file)
            if m4a_file:
                converted_files.append(m4a_file)

        return converted_files

    def extract_youtube_video_id(self, url: str) -> str | None:
        """Extract YouTube video ID from URL

        Supported URL patterns:
        - https://www.youtube.com/watch?v=VIDEO_ID
        - https://youtu.be/VIDEO_ID
        - https://m.youtube.com/watch?v=VIDEO_ID

        Returns:
            Video ID (11 characters) if found, None otherwise
        """
        match = re.search(r'(?:youtube\.com/watch\?v=|youtu\.be/)([A-Za-z0-9_-]{11})', url)
        return match.group(1) if match else None

    def get_thumbnail_path_for_file(self, filepath: Path, video_id: str) -> Path:
        """Determine thumbnail filename for a file

        Naming strategy:
        - Single file in directory: cover.jpg
        - Multiple files: youtube_{VIDEO_ID}.jpg

        Args:
            filepath: Path to audio file
            video_id: YouTube video ID

        Returns:
            Path to thumbnail file
        """
        directory = filepath.parent
        audio_files = self.find_audio_files(str(directory))

        if len(audio_files) == 1:
            return directory / "cover.jpg"
        else:
            return directory / f"youtube_{video_id}.jpg"

    def download_youtube_thumbnail(self, video_id: str, output_path: Path) -> bool:
        """Download YouTube thumbnail and crop to square

        Args:
            video_id: YouTube video ID (11 characters)
            output_path: Path where thumbnail should be saved

        Returns:
            True if successful, False otherwise
        """
        # Try yt-dlp first
        try:
            import yt_dlp

            temp_path = output_path.with_suffix('')
            ydl_opts = {
                'skip_download': True,
                'writethumbnail': True,
                'outtmpl': str(temp_path),
                'quiet': True,
                'no_warnings': True,
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                url = f"https://www.youtube.com/watch?v={video_id}"
                ydl.download([url])

            # Find downloaded thumbnail (yt-dlp adds extension)
            downloaded_files = list(temp_path.parent.glob(f"{temp_path.name}.*"))
            if not downloaded_files:
                raise Exception("Thumbnail not downloaded")

            downloaded_path = downloaded_files[0]

        except ImportError:
            self.log("Note: yt-dlp not installed, using direct URL")
            try:
                import requests

                # Try maxresdefault first, fallback to hqdefault
                urls = [
                    f'https://img.youtube.com/vi/{video_id}/maxresdefault.jpg',
                    f'https://img.youtube.com/vi/{video_id}/hqdefault.jpg',
                ]

                downloaded_path = None
                for url in urls:
                    response = requests.get(url, timeout=10)
                    if response.status_code == 200:
                        temp_file = output_path.with_suffix('.tmp.jpg')
                        with open(temp_file, 'wb') as f:
                            f.write(response.content)
                        downloaded_path = temp_file
                        break

                if not downloaded_path:
                    return False

            except ImportError:
                self.log("Warning: Neither yt-dlp nor requests available")
                return False
            except Exception as e:
                self.log(f"Warning: Failed to download thumbnail: {e}")
                return False
        except Exception as e:
            self.log(f"Warning: yt-dlp failed: {e}")
            return False

        # Crop to square
        try:
            from PIL import Image

            img = Image.open(downloaded_path)
            width, height = img.size

            # Crop to square (center crop)
            if width > height:
                left = (width - height) // 2
                img_cropped = img.crop((left, 0, left + height, height))
            else:
                top = (height - width) // 2
                img_cropped = img.crop((0, top, width, top + width))

            # Save as JPEG
            img_cropped.save(output_path, 'JPEG', quality=95)

            # Clean up temporary file
            if downloaded_path != output_path:
                downloaded_path.unlink()

        except ImportError:
            self.log("Note: Pillow not installed, skipping square crop")
            # Just rename/move the file
            if downloaded_path != output_path:
                shutil.move(str(downloaded_path), str(output_path))
        except Exception as e:
            self.log(f"Warning: Failed to crop thumbnail: {e}")
            # Keep original if crop fails
            if downloaded_path != output_path:
                shutil.move(str(downloaded_path), str(output_path))

        return True

    def parse_filename(self, filename: str) -> dict[str, any]:
        """Parse metadata from filename

        Supported patterns (spaces are flexible, 1+ spaces allowed):
        - Label - Artist - Title [ID].mp3 -> label="Label", artist="Artist", title="Title", bandcamp_id="ID"
        - Label - Album - 01 Artist - Title.mp3 -> label="Label", album="Album", track=1, artist="Artist", title="Title"
        - Label - Album - 01 - Title.mp3 -> label="Label", album="Album", track=1, title="Title"
        - Artist - Title [YOUTUBE_ID].mp3 -> artist="Artist", title="Title", comment="https://www.youtube.com/watch?v=YOUTUBE_ID"
        - 1. Artist - Title.mp3 -> track=1, artist="Artist", title="Title"
        - 01 Artist - Title.mp3 -> track=1, artist="Artist", title="Title"
        - 01  - Title.mp3 -> track=1, artist="", title="Title"
        - 01 Title.mp3 -> track=1, artist="", title="Title"
        - Artist - Title.mp3 -> artist="Artist", title="Title"
        - Title.mp3 -> title="Title"
        """
        # Remove extension
        name = Path(filename).stem

        track = None
        artist = None
        title = None
        album = None
        label = None
        bandcamp_id = None
        comment = None

        # Check for YouTube ID pattern [VIDEO_ID] at the end
        # YouTube IDs are typically 11 characters: alphanumeric, hyphens, underscores
        youtube_match = re.search(r'\[([A-Za-z0-9_-]{11})\]$', name)
        if youtube_match:
            video_id = youtube_match.group(1)
            comment = f"https://www.youtube.com/watch?v={video_id}"
            # Remove the [VIDEO_ID] part from the name for further parsing
            name = name[:youtube_match.start()].strip()

        # Try patterns in order of specificity (spaces: 1+ allowed)
        # Pattern 0: "Label - Artist - Title [ID]" (Bandcamp format)
        match = re.match(r"^(.+?)\s+-\s+(.+?)\s+-\s+(.+?)\s+\[(\d+)\]$", name)
        if match:
            label = match.group(1).strip()
            artist = match.group(2).strip()
            title = match.group(3).strip()
            bandcamp_id = match.group(4).strip()
            return {
                "track": None,
                "artist": artist if artist else None,
                "title": title if title else None,
                "label": label if label else None,
                "bandcamp_id": bandcamp_id if bandcamp_id else None,
                "comment": comment,
            }

        # Pattern 0a: "Label - Album - 01 Artist - Title" (Label + Album + Track + Artist + Title)
        match = re.match(r"^(.+?)\s+-\s+(.+?)\s+-\s+(\d+)\s+(.+?)\s+-\s+(.+)$", name)
        if match:
            label = match.group(1).strip()
            album = match.group(2).strip()
            track = int(match.group(3))
            artist = match.group(4).strip()
            title = match.group(5).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": album if album else None,
                "label": label if label else None,
                "comment": comment,
            }

        # Pattern 0b: "Label - Album - 01 - Title" (Label + Album + Track + Title, no artist)
        match = re.match(r"^(.+?)\s+-\s+(.+?)\s+-\s+(\d+)\s+-\s+(.+)$", name)
        if match:
            label = match.group(1).strip()
            album = match.group(2).strip()
            track = int(match.group(3))
            title = match.group(4).strip()
            return {
                "track": track,
                "artist": None,
                "title": title if title else None,
                "album": album if album else None,
                "label": label if label else None,
                "comment": comment,
            }

        # Pattern 1: "1. Artist - Title" (track with dot + artist + title)
        match = re.match(r"^(\d+)\.\s+(.+?)\s+-\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = match.group(2).strip()
            title = match.group(3).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 2: "01 Artist - Title" (track + artist + title)
        match = re.match(r"^(\d+)\s+(.+?)\s+-\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = match.group(2).strip()
            title = match.group(3).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 3: "01  - Title" (track + title, no artist)
        match = re.match(r"^(\d+)\s+-\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = ""
            title = match.group(2).strip()
            return {
                "track": track,
                "artist": None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 4: "01 Title" (track + title, no separator)
        match = re.match(r"^(\d+)\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = ""
            title = match.group(2).strip()
            return {
                "track": track,
                "artist": None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 5: "Artist - Title" (artist + title, no track)
        match = re.match(r"^(.+?)\s+-\s+(.+)$", name)
        if match:
            track = None
            artist = match.group(1).strip()
            title = match.group(2).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 6: "Title" (title only)
        title = name.strip()
        return {
            "track": None,
            "artist": None,
            "title": title if title else None,
            "album": None,
            "comment": comment,
        }

    def read_tags(self, filepath: Path) -> dict[str, any]:
        """Read tags from an audio file"""
        ext = filepath.suffix.lower()
        tags = {
            "filename": filepath.name,
            "track": None,
            "artist": None,
            "title": None,
            "album": None,
            "albumartist": None,
            "genre": None,
            "year": None,
            "artwork": None,
            "compilation": None,
            "label": None,
            "bandcamp_id": None,
            "disc": None,
            "comment": None,
        }

        try:
            if ext == ".mp3":
                audio = MP3(str(filepath), ID3=ID3)
                if audio.tags:
                    # Track number
                    if "TRCK" in audio.tags:
                        track_str = str(audio.tags["TRCK"])
                        tags["track"] = (
                            int(track_str.split("/")[0])
                            if "/" in track_str
                            else int(track_str)
                        )

                    # Disc number
                    if "TPOS" in audio.tags:
                        disc_str = str(audio.tags["TPOS"])
                        tags["disc"] = (
                            int(disc_str.split("/")[0])
                            if "/" in disc_str
                            else int(disc_str)
                        )

                    # Text fields
                    if "TIT2" in audio.tags:
                        tags["title"] = str(audio.tags["TIT2"])
                    if "TPE1" in audio.tags:
                        tags["artist"] = str(audio.tags["TPE1"])
                    if "TALB" in audio.tags:
                        tags["album"] = str(audio.tags["TALB"])
                    if "TPE2" in audio.tags:
                        tags["albumartist"] = str(audio.tags["TPE2"])
                    if "TCON" in audio.tags:
                        tags["genre"] = str(audio.tags["TCON"])
                    if "TDRC" in audio.tags:
                        tags["year"] = int(str(audio.tags["TDRC"]))
                    if "TCMP" in audio.tags:
                        tags["compilation"] = str(audio.tags["TCMP"]) == "1"

                    # Artwork (APIC frames can have different descriptions like "APIC:Cover", "APIC:", etc.)
                    has_artwork = any(
                        key.startswith("APIC:") for key in audio.tags.keys()
                    )
                    if has_artwork:
                        tags["artwork"] = "<embedded>"

                    # Custom tags (TXXX frames)
                    if "TXXX:LABEL" in audio.tags:
                        tags["label"] = str(audio.tags["TXXX:LABEL"])
                    if "TXXX:BANDCAMP_ID" in audio.tags:
                        tags["bandcamp_id"] = str(audio.tags["TXXX:BANDCAMP_ID"])

                    # Comment (COMM frame)
                    if "COMM::eng" in audio.tags:
                        tags["comment"] = str(audio.tags["COMM::eng"])
                    elif "COMM::" in audio.tags:
                        tags["comment"] = str(audio.tags["COMM::"])

            elif ext == ".m4a":
                audio = MP4(str(filepath))
                if audio.tags:
                    # Track number
                    if "\xa9nam" in audio.tags:
                        tags["title"] = audio.tags["\xa9nam"][0]
                    if "\xa9ART" in audio.tags:
                        tags["artist"] = audio.tags["\xa9ART"][0]
                    if "\xa9alb" in audio.tags:
                        tags["album"] = audio.tags["\xa9alb"][0]
                    if "aART" in audio.tags:
                        tags["albumartist"] = audio.tags["aART"][0]
                    if "\xa9gen" in audio.tags:
                        tags["genre"] = audio.tags["\xa9gen"][0]
                    if "\xa9day" in audio.tags:
                        tags["year"] = int(audio.tags["\xa9day"][0])
                    if "trkn" in audio.tags:
                        tags["track"] = audio.tags["trkn"][0][0]
                    if "disk" in audio.tags:
                        tags["disc"] = audio.tags["disk"][0][0]
                    if "cpil" in audio.tags:
                        tags["compilation"] = bool(audio.tags["cpil"][0])

                    # Artwork
                    if "covr" in audio.tags:
                        tags["artwork"] = "<embedded>"

                    # Comment
                    if "\xa9cmt" in audio.tags:
                        tags["comment"] = audio.tags["\xa9cmt"][0]

                    # Custom tags (freeform)
                    if "----:com.apple.iTunes:LABEL" in audio.tags:
                        tags["label"] = audio.tags["----:com.apple.iTunes:LABEL"][
                            0
                        ].decode("utf-8")
                    if "----:com.apple.iTunes:BANDCAMP_ID" in audio.tags:
                        tags["bandcamp_id"] = audio.tags[
                            "----:com.apple.iTunes:BANDCAMP_ID"
                        ][0].decode("utf-8")

        except Exception as e:
            self.log(f"Warning: Could not read tags from {filepath}: {e}")

        # If track, artist, title, album, label, bandcamp_id, or comment is missing, try to parse from filename
        # Or if prefer_filename is True, always parse and use filename values
        if (
            self.prefer_filename
            or tags["track"] is None
            or tags["artist"] is None
            or tags["title"] is None
            or tags["album"] is None
            or tags["label"] is None
            or tags["bandcamp_id"] is None
            or tags["comment"] is None
        ):
            parsed = self.parse_filename(filepath.name)

            if (self.prefer_filename or tags["track"] is None) and parsed.get(
                "track"
            ) is not None:
                tags["track"] = parsed["track"]
            if (self.prefer_filename or tags["artist"] is None) and parsed.get(
                "artist"
            ) is not None:
                tags["artist"] = parsed["artist"]
            if (self.prefer_filename or tags["title"] is None) and parsed.get(
                "title"
            ) is not None:
                tags["title"] = parsed["title"]
            if (self.prefer_filename or tags["album"] is None) and parsed.get(
                "album"
            ) is not None:
                tags["album"] = parsed["album"]
            if (self.prefer_filename or tags["label"] is None) and parsed.get(
                "label"
            ) is not None:
                tags["label"] = parsed["label"]
            if (self.prefer_filename or tags["bandcamp_id"] is None) and parsed.get(
                "bandcamp_id"
            ) is not None:
                tags["bandcamp_id"] = parsed["bandcamp_id"]
            if (self.prefer_filename or tags["comment"] is None) and parsed.get(
                "comment"
            ) is not None:
                tags["comment"] = parsed["comment"]

        return tags

    def _compare_tags(
        self, current: dict[str, any], expected: dict[str, any]
    ) -> dict[str, tuple[any, any]]:
        """
        Compare current tags with expected tags and return differences.
        Returns a dict of {field: (current_value, expected_value)} for fields that differ.
        """
        differences = {}

        # Fields to compare (excluding 'filename' which is not a tag)
        comparable_fields = [
            "track",
            "artist",
            "title",
            "album",
            "albumartist",
            "genre",
            "year",
            "compilation",
            "label",
            "bandcamp_id",
            "artwork",
            "disc",
            "comment",
        ]

        for field in comparable_fields:
            expected_value = expected.get(field)
            current_value = current.get(field)

            # Special handling for artwork
            if field == "artwork":
                # If YAML specifies a file path, we need to check if it matches embedded artwork
                if expected_value and expected_value != "<embedded>":
                    # YAML wants to set artwork from file
                    if current_value != "<embedded>":
                        differences[field] = (current_value, expected_value)
                elif expected_value == "<embedded>":
                    # YAML expects embedded artwork to exist
                    if current_value != "<embedded>":
                        differences[field] = (current_value, expected_value)
                # If expected_value is None, we don't care about artwork
                continue

            # For other fields, only compare if expected value is not None
            # (None means "not specified in YAML, don't modify")
            if expected_value is not None and current_value != expected_value:
                differences[field] = (current_value, expected_value)

        return differences

    def write_tags(self, filepath: Path, tags: dict[str, any]) -> bool:
        """Write tags to an audio file"""
        ext = filepath.suffix.lower()

        # Read current tags to check if update is needed
        current_tags = self.read_tags(filepath)
        differences = self._compare_tags(current_tags, tags)

        if self.dry_run:
            if differences:
                self.log(f"Would update tags for: {filepath}")
            # Don't output anything if tags are already up-to-date
            return True

        # Skip update if no differences
        if not differences:
            return True

        try:
            if ext == ".mp3":
                audio = MP3(str(filepath), ID3=ID3)

                # Create ID3 tag if it doesn't exist
                if audio.tags is None:
                    audio.add_tags()

                # Set tags
                if tags.get("title"):
                    audio.tags.add(TIT2(encoding=3, text=tags["title"]))
                if tags.get("artist"):
                    audio.tags.add(TPE1(encoding=3, text=tags["artist"]))
                if tags.get("album"):
                    audio.tags.add(TALB(encoding=3, text=tags["album"]))
                if tags.get("albumartist"):
                    audio.tags.add(TPE2(encoding=3, text=tags["albumartist"]))
                if tags.get("genre"):
                    audio.tags.add(TCON(encoding=3, text=tags["genre"]))
                if tags.get("year"):
                    audio.tags.add(TDRC(encoding=3, text=str(tags["year"])))
                if tags.get("track"):
                    audio.tags.add(TRCK(encoding=3, text=str(tags["track"])))
                if tags.get("disc"):
                    audio.tags.add(TPOS(encoding=3, text=str(tags["disc"])))
                if tags.get("compilation") is not None:
                    audio.tags.add(
                        TCMP(encoding=3, text="1" if tags["compilation"] else "0")
                    )

                # Custom tags
                if tags.get("label"):
                    audio.tags.add(TXXX(encoding=3, desc="LABEL", text=tags["label"]))
                if tags.get("bandcamp_id"):
                    audio.tags.add(
                        TXXX(encoding=3, desc="BANDCAMP_ID", text=tags["bandcamp_id"])
                    )

                # Comment
                if tags.get("comment"):
                    audio.tags.add(
                        COMM(encoding=3, lang="eng", desc="", text=tags["comment"])
                    )

                # Artwork
                if tags.get("artwork") and tags["artwork"] != "<embedded>":
                    artwork_path = Path(tags["artwork"])
                    if artwork_path.exists():
                        with open(artwork_path, "rb") as f:
                            audio.tags.add(
                                APIC(
                                    encoding=3,
                                    mime=(
                                        "image/jpeg"
                                        if artwork_path.suffix.lower()
                                        in [".jpg", ".jpeg"]
                                        else "image/png"
                                    ),
                                    type=3,  # Cover (front)
                                    desc="Cover",
                                    data=f.read(),
                                )
                            )

                audio.save()

            elif ext == ".m4a":
                audio = MP4(str(filepath))

                # Set tags
                if tags.get("title"):
                    audio.tags["\xa9nam"] = tags["title"]
                if tags.get("artist"):
                    audio.tags["\xa9ART"] = tags["artist"]
                if tags.get("album"):
                    audio.tags["\xa9alb"] = tags["album"]
                if tags.get("albumartist"):
                    audio.tags["aART"] = tags["albumartist"]
                if tags.get("genre"):
                    audio.tags["\xa9gen"] = tags["genre"]
                if tags.get("year"):
                    audio.tags["\xa9day"] = str(tags["year"])
                if tags.get("track"):
                    audio.tags["trkn"] = [(tags["track"], 0)]
                if tags.get("disc"):
                    audio.tags["disk"] = [(tags["disc"], 0)]
                if tags.get("compilation") is not None:
                    audio.tags["cpil"] = [tags["compilation"]]

                # Comment
                if tags.get("comment"):
                    audio.tags["\xa9cmt"] = tags["comment"]

                # Custom tags
                if tags.get("label"):
                    audio.tags["----:com.apple.iTunes:LABEL"] = tags["label"].encode(
                        "utf-8"
                    )
                if tags.get("bandcamp_id"):
                    audio.tags["----:com.apple.iTunes:BANDCAMP_ID"] = tags[
                        "bandcamp_id"
                    ].encode("utf-8")

                # Artwork
                if tags.get("artwork") and tags["artwork"] != "<embedded>":
                    artwork_path = Path(tags["artwork"])
                    if artwork_path.exists():
                        with open(artwork_path, "rb") as f:
                            cover_data = f.read()
                            if artwork_path.suffix.lower() == ".png":
                                audio.tags["covr"] = [
                                    MP4Cover(
                                        cover_data, imageformat=MP4Cover.FORMAT_PNG
                                    )
                                ]
                            else:
                                audio.tags["covr"] = [
                                    MP4Cover(
                                        cover_data, imageformat=MP4Cover.FORMAT_JPEG
                                    )
                                ]

                audio.save()

            self.log(f"Updated tags for: {filepath}")
            return True

        except Exception as e:
            self.log(f"Error: Could not write tags to {filepath}: {e}")
            return False

    def sanitize_filename(self, name: str) -> str:
        """Sanitize filename by removing invalid characters"""
        invalid_chars = '<>:"/\\|?*'
        for char in invalid_chars:
            name = name.replace(char, "_")
        return name

    def generate_filename(
        self, tags: dict[str, any], max_track: int | None = None
    ) -> str:
        """Generate filename from tags

        Args:
            tags: Dictionary of tag values
            max_track: Maximum track number (for padding). If None, uses 2 digits minimum.
        """
        track = tags.get("track", "")
        disc = tags.get("disc", "")
        artist = tags.get("artist", "")
        title = tags.get("title", "Unknown Title")

        # Get original extension
        original_filename = tags.get("filename", ".mp3")
        ext = Path(original_filename).suffix

        # Determine padding width based on max_track
        # Always use at least 2 digits, even if max_track is single digit
        if max_track is not None and max_track > 0:
            padding = max(2, len(str(max_track)))
        else:
            padding = 2  # Default to 2 digits

        # Build track prefix with optional disc number
        # Disc number is always 2 digits: 01-01, 02-03, etc.
        track_prefix = ""
        if track:
            if disc:
                track_prefix = f"{disc:02d}-{track:0{padding}d}"
            else:
                track_prefix = f"{track:0{padding}d}"

        # Build filename based on available metadata
        # Hyphens use 1 space before and after, except track-only uses 2 spaces before hyphen
        if track_prefix and artist:
            # Format: 01-01 Artist - Title.mp3 (with disc) or 01 Artist - Title.mp3 (without disc)
            filename = f"{track_prefix} {artist} - {title}{ext}"
        elif track_prefix:
            # Format: 01-01  - Title.mp3 (no artist, 2 spaces before hyphen)
            filename = f"{track_prefix}  - {title}{ext}"
        elif artist:
            # Format: Artist - Title.mp3 (no track)
            filename = f"{artist} - {title}{ext}"
        else:
            # Format: Title.mp3 (no track, no artist)
            filename = f"{title}{ext}"

        return self.sanitize_filename(filename)

    def rename_file(self, old_path: Path, new_filename: str) -> Path | None:
        """Rename a file"""
        new_path = old_path.parent / new_filename

        if old_path == new_path:
            return old_path

        if self.dry_run:
            self.log(f"Would rename: {old_path.name} -> {new_filename}")
            return new_path

        try:
            old_path.rename(new_path)
            self.log(f"Renamed: {old_path.name} -> {new_filename}")
            return new_path
        except Exception as e:
            self.log(f"Error: Could not rename {old_path}: {e}")
            return None

    def compare_tags(
        self, current: dict, yaml_data: dict, filepath: Path | None = None
    ) -> dict:
        """Compare current tags with YAML data and return differences

        For artwork, compares actual file contents if filepath is provided
        """
        diff = {}
        all_keys = set(current.keys()) | set(yaml_data.keys())

        for key in all_keys:
            current_val = current.get(key)
            yaml_val = yaml_data.get(key)

            # Special handling for artwork comparison
            if key == "artwork" and filepath:
                # If current has embedded artwork and YAML specifies a file
                if (
                    current_val == "<embedded>"
                    and yaml_val
                    and yaml_val != "<embedded>"
                ):
                    # Compare actual file contents
                    if self.compare_artwork(filepath, yaml_val):
                        # Artwork is the same, skip diff
                        continue
                # If both are "<embedded>", they're the same
                elif current_val == "<embedded>" and yaml_val == "<embedded>":
                    continue

            if current_val != yaml_val:
                diff[key] = {"current": current_val, "yaml": yaml_val}

        return diff

    def show_diff(self, yaml_file: str = "tagger.yaml"):
        """Show differences between current state and YAML file"""
        if not os.path.exists(yaml_file):
            self.log(f"Error: {yaml_file} not found")
            return

        # First, convert any .aac files to .m4a
        self.find_and_convert_aac_files()

        # Load YAML file
        with open(yaml_file, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)

        # Validate YAML structure
        try:
            config = TaggerConfig(**data)
        except ValidationError as e:
            self.log(f"Error: YAML validation failed for {yaml_file}:")
            for error in e.errors():
                field = " -> ".join(str(x) for x in error["loc"])
                self.log(f"  {field}: {error['msg']}")
            return

        # Get defaults from YAML
        defaults = (
            config.defaults.model_dump(exclude_none=True, mode="python")
            if config.defaults
            else {}
        )

        # Get current files
        files = self.find_audio_files()
        current_files = {f.name: f for f in files}

        # Get YAML files
        yaml_files = {f.filename: f for f in config.files}

        # Find files only in YAML (deleted files)
        deleted_files = set(yaml_files.keys()) - set(current_files.keys())

        # Find files only in current directory (new files)
        new_files = set(current_files.keys()) - set(yaml_files.keys())

        # Find common files (potentially modified)
        common_files = set(current_files.keys()) & set(yaml_files.keys())

        has_changes = False

        # Show deleted files
        if deleted_files:
            has_changes = True
            print("\n" + self.color("=" * 60, "dim"))
            print(
                self.color(
                    "DELETED FILES (in YAML but not in directory):", "red", "bold"
                )
            )
            print(self.color("=" * 60, "dim"))
            for filename in sorted(deleted_files):
                print(f"  {self.color('-', 'red')} {self.color(filename, 'red')}")

        # Show new files
        if new_files:
            has_changes = True
            print("\n" + self.color("=" * 60, "dim"))
            print(
                self.color("NEW FILES (in directory but not in YAML):", "green", "bold")
            )
            print(self.color("=" * 60, "dim"))
            for filename in sorted(new_files):
                filepath = current_files[filename]
                current_tags = self.read_tags(filepath)
                print(f"\n  {self.color(filename, 'green', 'bold')}:")
                for key, value in current_tags.items():
                    if key != "filename" and value is not None:
                        print(f"    {self.color(key, 'cyan')}: {value}")

        # Show modified files
        modified_files = []
        for filename in sorted(common_files):
            filepath = current_files[filename]
            current_tags = self.read_tags(filepath)

            # Get YAML data for this file
            yaml_file_data = next(
                f.model_dump(exclude_none=True, mode="python")
                for f in config.files
                if f.filename == filename
            )

            # Merge defaults with file-specific data
            yaml_tags = defaults | yaml_file_data

            # Compare tags (pass filepath for artwork comparison)
            diff = self.compare_tags(current_tags, yaml_tags, filepath)

            if diff:
                modified_files.append((filename, diff))

        if modified_files:
            has_changes = True
            print("\n" + self.color("=" * 60, "dim"))
            print(
                self.color(
                    "MODIFIED FILES (differences between current and YAML):",
                    "yellow",
                    "bold",
                )
            )
            print(self.color("=" * 60, "dim"))
            for filename, diff in modified_files:
                print(f"\n  {self.color(filename, 'yellow', 'bold')}:")
                for key, values in diff.items():
                    if key == "filename":
                        continue
                    current_val = values["current"]
                    yaml_val = values["yaml"]
                    print(f"    {self.color(key, 'cyan')}:")
                    print(
                        f"      {self.color('current:', 'green')} {self.color(str(current_val), 'green')}"
                    )
                    print(
                        f"      {self.color('yaml:   ', 'red')} {self.color(str(yaml_val), 'red')}"
                    )

        if not has_changes:
            print("\n" + self.color("=" * 60, "dim"))
            print(self.color("NO CHANGES DETECTED", "green", "bold"))
            print(self.color("=" * 60, "dim"))
            print(
                f"\n{self.color('✓', 'green')} Current directory state matches {self.color(yaml_file, 'cyan')}"
            )

    def generate_yaml(self, output_file: str = "tagger.yaml", interactive: bool = True):
        """Generate YAML file from current directory audio files

        Args:
            output_file: Output YAML filename
            interactive: If True, prompt user for preferences when conflicts exist
        """
        # First, convert any .aac files to .m4a
        self.find_and_convert_aac_files()

        files = self.find_audio_files()

        if not files:
            self.log("No audio files found in current directory")
            return

        self.log(f"Found {len(files)} audio file(s)")

        # Check if any files have both embedded tags and parseable filenames
        # If so, ask user which to prefer
        if interactive and not self.dry_run:
            has_conflict = False
            for filepath in files:
                # Temporarily read tags without filename parsing
                old_prefer = self.prefer_filename
                self.prefer_filename = False
                tags_only = self.read_tags(filepath)
                self.prefer_filename = old_prefer

                parsed = self.parse_filename(filepath.name)

                # Check if both have artist and title
                if (
                    tags_only.get("artist")
                    and parsed.get("artist")
                    and tags_only.get("artist") != parsed.get("artist")
                ) or (
                    tags_only.get("title")
                    and parsed.get("title")
                    and tags_only.get("title") != parsed.get("title")
                ):
                    has_conflict = True
                    break

            if has_conflict:
                print(
                    "\n"
                    + self.color(
                        "Some files have different information in tags vs. filenames.",
                        "yellow",
                    )
                )
                print(
                    "Which source should be preferred when generating the YAML file?\n"
                )
                print("  1. Embedded tags (default)")
                print("  2. Filenames")
                print()

                while True:
                    choice = input("Enter your choice (1 or 2) [1]: ").strip()
                    if choice == "" or choice == "1":
                        self.prefer_filename = False
                        break
                    elif choice == "2":
                        self.prefer_filename = True
                        break
                    else:
                        print("Invalid choice. Please enter 1 or 2.")

        # Read tags from all files
        entries = []
        artwork_downloads = {}  # Track thumbnails to download (video_id: path)

        for filepath in files:
            tags = self.read_tags(filepath)

            # Check for YouTube URL in comment field
            comment = tags.get('comment')
            if comment and 'youtube.com' in comment:
                video_id = self.extract_youtube_video_id(comment)
                if video_id:
                    thumbnail_path = self.get_thumbnail_path_for_file(filepath, video_id)

                    # Skip if thumbnail already exists
                    if not thumbnail_path.exists():
                        artwork_downloads[video_id] = thumbnail_path

                    # Set artwork if not already present
                    if not tags.get('artwork'):
                        tags['artwork'] = str(thumbnail_path.name)  # Relative path

            # Remove None values
            entry = {k: v for k, v in tags.items() if v is not None}
            entries.append(entry)

        # Download thumbnails (execute mode only)
        if not self.dry_run and artwork_downloads:
            self.log(f"Downloading {len(artwork_downloads)} YouTube thumbnail(s)...")
            for idx, (video_id, path) in enumerate(artwork_downloads.items(), 1):
                print(f"  [{idx}/{len(artwork_downloads)}] {video_id}...", end='', flush=True)
                if self.download_youtube_thumbnail(video_id, path):
                    print(" ✓")
                else:
                    print(" ✗ Failed")

        # Extract common fields to defaults
        common_fields = [
            "album",
            "albumartist",
            "genre",
            "year",
            "artwork",
            "compilation",
            "label",
            "bandcamp_id",
            "disc",
            "comment",
        ]
        defaults = {}

        if len(entries) > 1:  # Only extract defaults if there are multiple files
            for field in common_fields:
                # Get all values for this field (excluding None)
                values = [entry.get(field) for entry in entries if field in entry]

                # If all files have the same non-None value, move to defaults
                if (
                    values
                    and len(values) == len(entries)
                    and len(set(str(v) for v in values)) == 1
                ):
                    defaults[field] = values[0]

            # Remove common fields from individual entries
            if defaults:
                for entry in entries:
                    for field in defaults:
                        entry.pop(field, None)

        # Sort entries by track number (entries without track number go last)
        def get_track_sort_key(entry):
            track = entry.get("track")
            if track is None:
                # Check if track is in defaults
                track = defaults.get("track")
            # Return tuple: (has_track, track_number)
            # Entries without track go last (True > False)
            if track is None:
                return (True, 0)
            return (False, track)

        entries_sorted = sorted(entries, key=get_track_sort_key)

        # Create YAML structure
        yaml_data = {}
        if defaults:
            yaml_data["defaults"] = defaults
        yaml_data["files"] = entries_sorted

        # Validate YAML structure
        try:
            config = TaggerConfig(**yaml_data)
            # Convert back to dict for YAML serialization
            yaml_data = config.model_dump(exclude_none=True, mode="python")
        except ValidationError as e:
            self.log(f"Error: Generated YAML validation failed:")
            for error in e.errors():
                field = " -> ".join(str(x) for x in error["loc"])
                self.log(f"  {field}: {error['msg']}")
            sys.exit(1)

        # Generate YAML string with schema comment
        schema_url = "https://raw.githubusercontent.com/delphinus/homebrew-tagger/main/tagger.schema.json"
        schema_comment = f"# yaml-language-server: $schema={schema_url}\n\n"

        yaml_str = yaml.dump(
            yaml_data, allow_unicode=True, default_flow_style=False, sort_keys=False
        )

        if self.dry_run:
            self.log(f"Would create {output_file} with content:")
            print("\n" + "=" * 60)
            print(schema_comment + yaml_str)
            print("=" * 60)
        else:
            with open(output_file, "w", encoding="utf-8") as f:
                f.write(schema_comment)
                f.write(yaml_str)
            self.log(f"Created {output_file}")

    def apply_yaml(self, yaml_file: str):
        """Apply tags and filenames from YAML file"""
        # First, convert any .aac files to .m4a
        self.find_and_convert_aac_files()

        if not os.path.exists(yaml_file):
            self.log(f"Error: YAML file not found: {yaml_file}")
            sys.exit(1)

        # Load YAML
        with open(yaml_file, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)

        # Validate YAML structure
        try:
            config = TaggerConfig(**data)
            self.log("YAML validation successful")
        except ValidationError as e:
            self.log(f"Error: YAML validation failed for {yaml_file}:")
            for error in e.errors():
                field = " -> ".join(str(x) for x in error["loc"])
                self.log(f"  {field}: {error['msg']}")
            self.log("\nCommon issues:")
            self.log(
                "  - Check for typos in field names (e.g., 'default' should be 'defaults')"
            )
            self.log("  - Ensure all required fields are present")
            self.log(
                "  - Verify data types (e.g., year should be a number, not a string)"
            )
            sys.exit(1)

        # Get defaults if present
        defaults = (
            config.defaults.model_dump(exclude_none=True, mode="python")
            if config.defaults
            else {}
        )

        files_data = [
            f.model_dump(exclude_none=True, mode="python") for f in config.files
        ]
        self.log(f"Processing {len(files_data)} file(s) from {yaml_file}")

        # Calculate maximum track number for padding
        max_track = 0
        for file_data in files_data:
            merged_data = defaults | file_data
            track = merged_data.get("track")
            if track is not None and track > max_track:
                max_track = track

        for file_data in files_data:
            if "filename" not in file_data:
                self.log("Warning: Skipping entry without 'filename'")
                continue

            original_filename = file_data["filename"]
            filepath = Path(original_filename)

            if not filepath.exists():
                self.log(f"Warning: File not found: {original_filename}")
                continue

            # Merge defaults with file-specific data (file-specific takes priority)
            merged_data = defaults | file_data

            # Write tags
            self.write_tags(filepath, merged_data)

            # Generate new filename with proper track padding
            new_filename = self.generate_filename(
                merged_data, max_track if max_track > 0 else None
            )

            # Rename file if needed
            new_path = self.rename_file(filepath, new_filename)

            # Update YAML entry with new filename for future reference
            if new_path and not self.dry_run:
                file_data["filename"] = new_path.name

        # Update YAML file with new filenames
        if not self.dry_run:
            # Sort files by track number (files without track number go last)
            def get_track_sort_key(file_data):
                merged = defaults | file_data
                track = merged.get("track")
                # Return tuple: (has_track, track_number)
                # Files without track go last (True > False)
                if track is None:
                    return (True, 0)
                return (False, track)

            files_data_sorted = sorted(files_data, key=get_track_sort_key)

            # Update the files list in data with the sorted files_data
            data["files"] = files_data_sorted
            with open(yaml_file, "w", encoding="utf-8") as f:
                yaml.dump(
                    data,
                    f,
                    allow_unicode=True,
                    default_flow_style=False,
                    sort_keys=False,
                )
            self.log(f"Updated {yaml_file} with new filenames")


def main():
    parser = argparse.ArgumentParser(
        description="Manage audio file tags and filenames using mutagen",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Show diff if tagger.yaml exists, otherwise generate YAML (dry-run)
  tagger

  # Generate YAML and save it (even if tagger.yaml exists)
  tagger --execute

  # Apply tags from YAML (dry-run)
  tagger tagger.yaml

  # Apply tags from YAML and execute
  tagger --execute tagger.yaml

Note:
  When running 'tagger' without arguments, if tagger.yaml exists in the current
  directory, it will show differences between the current state and the YAML file.
  This helps you see what has changed before updating the YAML or applying tags.
        """,
    )

    parser.add_argument(
        "yaml_file",
        nargs="?",
        help="YAML file with tag information (if not provided, generates YAML from current directory)",
    )

    parser.add_argument(
        "-e",
        "--execute",
        action="store_true",
        help="Execute changes (default is dry-run mode)",
    )

    parser.add_argument(
        "-o",
        "--output",
        default="tagger.yaml",
        help="Output YAML file name when generating (default: tagger.yaml)",
    )

    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
    )

    parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable colored output",
    )

    parser.add_argument(
        "--prefer-filename",
        action="store_true",
        help="Prefer metadata from filenames over embedded tags when generating YAML (non-interactive mode)",
    )

    parser.add_argument(
        "--segment",
        metavar="AUDIO_FILE",
        help="Segment a DJ mix and generate CUE sheet (use with --sensitivity to adjust detection)",
    )

    parser.add_argument(
        "--sensitivity",
        type=float,
        default=0.5,
        help="Detection sensitivity for DJ mix segmentation (0.0-1.0, default: 0.5)",
    )

    parser.add_argument(
        "--tracklist",
        help="Tracklist source: 'clipboard', file path, or SoundCloud URL",
    )

    parser.add_argument(
        "--tracklist-file",
        help="Read tracklist from a text file",
    )

    parser.add_argument(
        "--tracklist-clipboard",
        action="store_true",
        help="Read tracklist from clipboard",
    )

    parser.add_argument(
        "--verify-boundaries",
        action="store_true",
        help="Verify detected boundaries using music recognition (requires --tracklist and --recognize or implicit recognition)",
    )

    parser.add_argument(
        "--recognize",
        action="store_true",
        help="Use music recognition to identify tracks in DJ mix (requires pyacoustid)",
    )

    args = parser.parse_args()

    # Segment mode (DJ mix analysis)
    if args.segment:
        # Show loading indicator while importing heavy libraries
        import threading
        import time

        loading_done = threading.Event()
        spinner_chars = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]

        def show_spinner():
            i = 0
            while not loading_done.is_set():
                print(
                    f"\r{spinner_chars[i % len(spinner_chars)]} Loading audio processing libraries...",
                    end="",
                    file=sys.stderr,
                    flush=True,
                )
                i += 1
                time.sleep(0.1)
            print("\r✓ Libraries loaded" + " " * 30, file=sys.stderr, flush=True)

        spinner_thread = threading.Thread(target=show_spinner, daemon=True)
        spinner_thread.start()

        try:
            from segmenter import segment_mix
            from tracklist_parser import TracklistParser

            loading_done.set()
            spinner_thread.join(timeout=0.5)
        except ImportError as e:
            loading_done.set()
            spinner_thread.join(timeout=0.5)
            print(
                f"\nError: Required module not available: {e}\n"
                "Please install with: pip install librosa",
                file=sys.stderr,
            )
            sys.exit(1)

        # Validate sensitivity
        if not 0.0 <= args.sensitivity <= 1.0:
            print("Error: Sensitivity must be between 0.0 and 1.0", file=sys.stderr)
            sys.exit(1)

        # Parse tracklist if provided
        tracklist = None
        if args.tracklist_clipboard:
            print("Reading tracklist from clipboard...", file=sys.stderr)
            tracklist = TracklistParser.from_clipboard()
            if tracklist:
                print(f"Found {len(tracklist)} tracks in clipboard", file=sys.stderr)
        elif args.tracklist_file:
            print(f"Reading tracklist from {args.tracklist_file}...", file=sys.stderr)
            tracklist = TracklistParser.from_file(args.tracklist_file)
            if tracklist:
                print(f"Found {len(tracklist)} tracks in file", file=sys.stderr)
        elif args.tracklist:
            # Auto-detect: clipboard, file, or URL
            if args.tracklist.lower() == "clipboard":
                tracklist = TracklistParser.from_clipboard()
            elif args.tracklist.startswith("http"):
                print(f"Extracting tracklist from {args.tracklist}...", file=sys.stderr)
                tracklist = TracklistParser.from_soundcloud(args.tracklist)
                if tracklist:
                    print(f"Found {len(tracklist)} tracks from URL", file=sys.stderr)
            else:
                # Assume it's a file path
                tracklist = TracklistParser.from_file(args.tracklist)
                if tracklist:
                    print(f"Found {len(tracklist)} tracks from file", file=sys.stderr)

        if tracklist:
            print("\nTracklist:", file=sys.stderr)
            for track in tracklist[:5]:  # Show first 5 tracks
                print(f"  {track}", file=sys.stderr)
            if len(tracklist) > 5:
                print(f"  ... and {len(tracklist) - 5} more", file=sys.stderr)
            print()

        # Determine output path
        output_path = None
        if args.output and args.output != "tagger.yaml":
            output_path = args.output
        else:
            # Default: same as audio file with .cue extension
            output_path = Path(args.segment).with_suffix(".cue")

        # Record start time for performance reporting
        start_time = time.time()

        try:
            segment_mix(
                args.segment,
                str(output_path),
                args.sensitivity,
                tracklist,
                recognize_tracks=args.recognize,
                verify_boundaries=args.verify_boundaries,
            )
        except Exception as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

        # Report execution time
        elapsed_time = time.time() - start_time
        print(f"\n{'='*60}", file=sys.stderr)
        print(f"Segmentation completed successfully!", file=sys.stderr)
        print(f"{'='*60}", file=sys.stderr)
        print(
            f"Total time: {elapsed_time:.2f} seconds ({elapsed_time/60:.2f} minutes)",
            file=sys.stderr,
        )
        print(f"Output: {output_path}", file=sys.stderr)
        print(f"{'='*60}", file=sys.stderr)

        sys.exit(0)

    # Regular tagger mode
    tagger = Tagger(
        execute=args.execute,
        no_color=args.no_color,
        prefer_filename=args.prefer_filename,
    )

    if args.yaml_file:
        # Apply mode
        tagger.apply_yaml(args.yaml_file)
    else:
        # Generate/Diff mode
        # If tagger.yaml exists in current directory, show diff instead of generating
        if os.path.exists("tagger.yaml") and not args.execute:
            tagger.show_diff("tagger.yaml")
        else:
            # If --prefer-filename is set, skip interactive mode
            interactive = not args.prefer_filename
            tagger.generate_yaml(args.output, interactive=interactive)


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
"""
Tagger - Audio file tag and filename manager using mutagen

This script manages tags and filenames for .mp3 and .m4a files.
It can also convert .aac files to .m4a format (lossless container conversion).
"""

__version__ = "1.25.4"

import argparse
import hashlib
import os
import re
import shutil
import subprocess
import sys
from pathlib import Path

import yaml

try:
    from mutagen.id3 import (
        APIC,
        COMM,
        ID3,
        TALB,
        TCMP,
        TCON,
        TDRC,
        TIT2,
        TPE1,
        TPE2,
        TPOS,
        TRCK,
        TXXX,
    )
    from mutagen.mp3 import MP3
    from mutagen.mp4 import MP4, MP4Cover
except ImportError:
    print(
        "Error: mutagen is not installed. Please install it with: pip install mutagen",
        file=sys.stderr,
    )
    sys.exit(1)

try:
    from pydantic import BaseModel, Field, ValidationError, field_validator
except ImportError:
    print(
        "Error: pydantic is not installed. Please install it with: pip install pydantic",
        file=sys.stderr,
    )
    sys.exit(1)


# Pydantic models for YAML schema validation
class Defaults(BaseModel):
    """Default values applied to all files"""

    model_config = {"extra": "forbid"}

    album: str | None = None
    albumartist: str | None = None
    genre: str | None = None
    year: int | None = None
    artwork: str | None = None
    compilation: bool | None = None
    label: str | None = None
    bandcamp_id: str | None = None
    disc: int | None = None
    comment: str | None = None

    @field_validator("year")
    @classmethod
    def validate_year(cls, v: int | None) -> int | None:
        """Validate year is reasonable"""
        if v is not None and (v < 1900 or v > 2100):
            raise ValueError("Year must be between 1900 and 2100")
        return v

    @field_validator("disc")
    @classmethod
    def validate_disc(cls, v: int | None) -> int | None:
        """Validate disc number is positive"""
        if v is not None and v < 1:
            raise ValueError("Disc number must be positive")
        return v


class FileEntry(BaseModel):
    """Schema for a single file entry in the YAML"""

    model_config = {"extra": "forbid"}

    filename: str = Field(..., description="Original filename")
    track: int | None = None
    artist: str | None = None
    title: str | None = None
    album: str | None = None
    albumartist: str | None = None
    genre: str | None = None
    year: int | None = None
    artwork: str | None = None
    compilation: bool | None = None
    label: str | None = None
    bandcamp_id: str | None = None
    disc: int | None = None
    comment: str | None = None

    @field_validator("track")
    @classmethod
    def validate_track(cls, v: int | None) -> int | None:
        """Validate track number is positive"""
        if v is not None and v < 1:
            raise ValueError("Track number must be positive")
        return v

    @field_validator("year")
    @classmethod
    def validate_year(cls, v: int | None) -> int | None:
        """Validate year is reasonable"""
        if v is not None and (v < 1900 or v > 2100):
            raise ValueError("Year must be between 1900 and 2100")
        return v

    @field_validator("disc")
    @classmethod
    def validate_disc(cls, v: int | None) -> int | None:
        """Validate disc number is positive"""
        if v is not None and v < 1:
            raise ValueError("Disc number must be positive")
        return v


class TaggerConfig(BaseModel):
    """Schema for the complete YAML configuration"""

    model_config = {"extra": "forbid"}

    defaults: Defaults | None = None
    files: list[FileEntry] = Field(..., min_length=1, description="List of audio files")

    @field_validator("files")
    @classmethod
    def validate_files_not_empty(cls, v: list[FileEntry]) -> list[FileEntry]:
        """Ensure files list is not empty"""
        if not v:
            raise ValueError("Files list cannot be empty")
        return v


class Tagger:
    """Main class for managing audio file tags and filenames"""

    SUPPORTED_EXTENSIONS = {".mp3", ".m4a"}

    # ANSI color codes
    COLORS = {
        "reset": "\033[0m",
        "red": "\033[91m",
        "green": "\033[92m",
        "yellow": "\033[93m",
        "blue": "\033[94m",
        "magenta": "\033[95m",
        "cyan": "\033[96m",
        "white": "\033[97m",
        "bold": "\033[1m",
        "dim": "\033[2m",
    }

    def __init__(
        self,
        execute: bool = False,
        no_color: bool = False,
        prefer_filename: bool = False,
        thumbnail_crop: str = "auto",
    ):
        self.execute = execute
        self.dry_run = not execute
        self.no_color = no_color or not sys.stdout.isatty()
        self.prefer_filename = prefer_filename
        self.thumbnail_crop = thumbnail_crop  # "auto", "square", "none"

    def color(self, text: str, *colors: str) -> str:
        """Apply color to text"""
        if self.no_color:
            return text
        color_codes = "".join(self.COLORS.get(c, "") for c in colors)
        return f"{color_codes}{text}{self.COLORS['reset']}"

    def log(self, message: str):
        """Print log message"""
        prefix = "[DRY-RUN] " if self.dry_run else ""
        print(f"{prefix}{message}")

    def can_display_images(self) -> tuple[bool, str]:
        """Check if terminal supports inline image display

        Returns:
            Tuple of (can_display, reason)
        """
        # Check if stdout is a tty
        if not sys.stdout.isatty():
            return False, "stdout is not a terminal (redirected or piped)"

        # Check terminal type via environment variables
        term_program = os.environ.get("TERM_PROGRAM", "")
        term = os.environ.get("TERM", "")

        # Known terminals that support iTerm2 inline images protocol
        supported_terminals = {
            "iTerm.app": "iTerm2",
            "WezTerm": "WezTerm",
            "mintty": "mintty (with imgcat)",
            "Konsole": "Konsole (recent versions)",
        }

        if term_program in supported_terminals:
            return True, ""

        # WezTerm also sets TERM_PROGRAM_VERSION
        if "wezterm" in term.lower() or os.environ.get(
            "TERM_PROGRAM_VERSION", ""
        ).startswith("wezterm"):
            return True, ""

        # If we can't detect the terminal type, assume it doesn't support images
        if term_program:
            return False, f"terminal '{term_program}' may not support inline images"
        else:
            return False, f"terminal type '{term}' may not support inline images"

    def display_image_iterm2(self, image_path: Path, max_width: int = 60):
        """Display image using iTerm2 inline images protocol

        Args:
            image_path: Path to image file
            max_width: Maximum display width in character cells (default: 60)
        """
        import base64

        with open(image_path, "rb") as f:
            image_data = f.read()

        encoded = base64.b64encode(image_data).decode("ascii")

        # iTerm2 inline images protocol
        # ESC ] 1337 ; File=inline=1;width=N:<base64 data> BEL
        # Width is specified in character cells, height is automatic (preserves aspect ratio)
        print(f"\033]1337;File=inline=1;width={max_width}:{encoded}\007")

    def create_crop_preview(self, image_path: Path) -> Path:
        """Create preview image showing crop area

        Args:
            image_path: Path to original image

        Returns:
            Path to annotated image
        """
        from PIL import Image, ImageDraw

        img = Image.open(image_path)
        width, height = img.size

        # Create annotated version showing crop area
        annotated = img.copy()
        draw = ImageDraw.Draw(annotated)

        # Calculate crop coordinates
        if width > height:
            left = (width - height) // 2
            crop_box = (left, 0, left + height, height)
        else:
            top = (height - width) // 2
            crop_box = (0, top, width, top + width)

        # Draw semi-transparent overlay on areas that will be cropped out
        overlay = Image.new("RGBA", img.size, (0, 0, 0, 0))
        overlay_draw = ImageDraw.Draw(overlay)

        # Darken the areas outside crop box
        if width > height:
            # Left area
            overlay_draw.rectangle((0, 0, left, height), fill=(0, 0, 0, 128))
            # Right area
            overlay_draw.rectangle(
                (left + height, 0, width, height), fill=(0, 0, 0, 128)
            )
        else:
            # Top area
            overlay_draw.rectangle((0, 0, width, top), fill=(0, 0, 0, 128))
            # Bottom area
            overlay_draw.rectangle((0, top + width, width, height), fill=(0, 0, 0, 128))

        # Composite the overlay
        if annotated.mode != "RGBA":
            annotated = annotated.convert("RGBA")
        annotated = Image.alpha_composite(annotated, overlay)
        annotated = annotated.convert("RGB")

        # Draw crop box border
        draw = ImageDraw.Draw(annotated)
        draw.rectangle(crop_box, outline=(255, 0, 0), width=3)

        # Save temporary file
        annotated_path = image_path.with_suffix(".annotated.jpg")
        annotated.save(annotated_path, "JPEG", quality=95)

        return annotated_path

    def ask_thumbnail_crop(self, image_path: Path) -> bool:
        """Ask user whether to crop thumbnail to square

        Args:
            image_path: Path to downloaded thumbnail

        Returns:
            True if user wants to crop, False otherwise
        """
        # Check if we can display images
        can_display, reason = self.can_display_images()

        if not can_display:
            print("\n" + "=" * 60)
            print(self.color("Warning: Cannot display thumbnail preview", "yellow"))
            print("=" * 60)
            print(f"Reason: {reason}")
            print("\nSupported terminals: iTerm2, WezTerm, Konsole, mintty")
            print(
                f"Your terminal: TERM_PROGRAM={os.environ.get('TERM_PROGRAM', '(not set)')}, TERM={os.environ.get('TERM', '(not set)')}"
            )
            print("\nApplying default: Keep original thumbnail (no cropping)")
            print("=" * 60)
            return False  # Default: no cropping

        print("\n" + "=" * 60)
        print("YouTube Thumbnail Preview:")
        print("=" * 60)

        try:
            from PIL import Image

            img = Image.open(image_path)
            width, height = img.size

            # Only show preview if image is not already square
            if width != height:
                # Create preview image with crop area
                annotated_path = self.create_crop_preview(image_path)

                print(f"\nOriginal image with crop area (red border):")
                print(f"Dimensions: {width}x{height}")
                crop_size = min(width, height)
                print(f"Crop to: {crop_size}x{crop_size}")
                try:
                    self.display_image_iterm2(annotated_path)
                except Exception as e:
                    self.log(f"Warning: Could not display annotated image: {e}")

                # Clean up temporary file
                try:
                    annotated_path.unlink()
                except Exception:
                    pass
            else:
                print(f"\nImage is already square ({width}x{height})")
                try:
                    self.display_image_iterm2(image_path)
                except Exception as e:
                    self.log(f"Warning: Could not display image: {e}")

        except Exception as e:
            self.log(f"Warning: Could not create preview: {e}")
            # Fallback to showing original image
            try:
                self.display_image_iterm2(image_path)
            except Exception:
                pass

        print("\nWould you like to crop this thumbnail to a square?")
        print("  1. Keep original (rectangular)")
        print("  2. Crop to square (center crop)")
        print()

        while True:
            choice = input("Enter your choice (1 or 2) [1]: ").strip()
            if choice == "" or choice == "1":
                return False  # Keep original
            elif choice == "2":
                return True  # Crop to square
            else:
                print("Invalid choice. Please enter 1 or 2.")

    def ask_frame_timestamp(
        self,
        video_id: str,
        output_path: Path,
        default_timestamp: float = 5.0,
        interactive: bool = True,
    ) -> float | None:
        """Interactively select timestamp for frame extraction with preview

        Args:
            video_id: YouTube video ID
            output_path: Path where final frame will be saved
            default_timestamp: Starting timestamp in seconds (default: 5.0)
            interactive: Whether to prompt for user input (default: True)

        Returns:
            Selected timestamp in seconds, or None if user cancels
        """
        # In non-interactive mode, just return the default timestamp
        if not interactive:
            return default_timestamp

        timestamp = default_timestamp

        while True:
            print("\n" + "=" * 60)
            print(f"Extracting frame from YouTube video at {timestamp} seconds...")
            print("=" * 60)

            # Download frame at current timestamp
            temp_preview = output_path.parent / f"temp_preview_{video_id}.jpg"
            success = self.download_youtube_frame(
                video_id, temp_preview, timestamp=timestamp, crop=False
            )

            if not success:
                print("\nFailed to extract frame. Using default.")
                if temp_preview.exists():
                    temp_preview.unlink()
                return default_timestamp

            # Display preview
            can_display, reason = self.can_display_images()

            if can_display:
                try:
                    from PIL import Image

                    img = Image.open(temp_preview)
                    width, height = img.size

                    print(f"\nPreview frame at {timestamp} seconds:")
                    print(f"Dimensions: {width}x{height}")

                    self.display_image_iterm2(temp_preview)

                except Exception as e:
                    self.log(f"Warning: Could not display preview: {e}")
            else:
                print(f"\nWarning: Cannot display preview ({reason})")

            print("\nIs this frame acceptable?")
            print("  1. Yes, use this frame")
            print("  2. No, try a different timestamp")
            print("  3. Cancel (use thumbnail instead)")
            print()

            while True:
                choice = input("Enter your choice (1, 2, or 3) [1]: ").strip()

                if choice == "" or choice == "1":
                    # Accept this frame
                    if temp_preview.exists():
                        temp_preview.unlink()
                    return timestamp

                elif choice == "2":
                    # Try different timestamp
                    new_timestamp = input(
                        f"Enter new timestamp in seconds [{timestamp}]: "
                    ).strip()

                    if new_timestamp == "":
                        # User pressed enter, keep current
                        continue

                    try:
                        timestamp = float(new_timestamp)
                        if timestamp < 0:
                            print("Timestamp must be positive. Try again.")
                            continue
                        # Break inner loop to re-extract frame
                        break

                    except ValueError:
                        print("Invalid timestamp. Please enter a number.")
                        continue

                elif choice == "3":
                    # Cancel, use thumbnail
                    if temp_preview.exists():
                        temp_preview.unlink()
                    return None

                else:
                    print("Invalid choice. Please enter 1, 2, or 3.")

    def get_artwork_hash(self, data: bytes) -> str:
        """Calculate SHA256 hash of artwork data"""
        return hashlib.sha256(data).hexdigest()

    def get_embedded_artwork(self, filepath: Path) -> bytes | None:
        """Extract embedded artwork from audio file"""
        ext = filepath.suffix.lower()

        try:
            if ext == ".mp3":
                audio = MP3(str(filepath), ID3=ID3)
                if audio.tags and "APIC:" in audio.tags:
                    return audio.tags["APIC:"].data
            elif ext == ".m4a":
                audio = MP4(str(filepath))
                if audio.tags and "covr" in audio.tags:
                    return bytes(audio.tags["covr"][0])
        except Exception:
            pass

        return None

    def compare_artwork(self, filepath: Path, artwork_path: str | None) -> bool:
        """Compare embedded artwork with external file

        Returns True if they are the same, False otherwise
        """
        if not artwork_path or artwork_path == "<embedded>":
            # Can't compare if no external file specified
            return False

        # Get embedded artwork
        embedded_data = self.get_embedded_artwork(filepath)
        if not embedded_data:
            # No embedded artwork
            return False

        # Get external artwork file
        external_path = Path(artwork_path)
        if not external_path.exists():
            # External file doesn't exist
            return False

        try:
            with open(external_path, "rb") as f:
                external_data = f.read()
        except Exception:
            return False

        # Compare hashes
        embedded_hash = self.get_artwork_hash(embedded_data)
        external_hash = self.get_artwork_hash(external_data)

        return embedded_hash == external_hash

    def find_audio_files(self, directory: str = ".") -> list[Path]:
        """Find all supported audio files in the directory"""
        path = Path(directory)
        files = []
        for ext in self.SUPPORTED_EXTENSIONS:
            files.extend(path.glob(f"*{ext}"))
        return sorted(files)

    def check_ffmpeg(self) -> bool:
        """Check if ffmpeg is available"""
        return shutil.which("ffmpeg") is not None

    def convert_aac_to_m4a(self, aac_file: Path) -> Path | None:
        """Convert AAC file to M4A format without re-encoding (lossless container conversion)"""
        if not self.check_ffmpeg():
            self.log("Warning: ffmpeg not found. Cannot convert .aac files to .m4a")
            return None

        m4a_file = aac_file.with_suffix(".m4a")

        if self.dry_run:
            self.log(f"Would convert: {aac_file.name} -> {m4a_file.name}")
            return m4a_file

        try:
            # Convert container without re-encoding (lossless)
            subprocess.run(
                ["ffmpeg", "-i", str(aac_file), "-c", "copy", "-y", str(m4a_file)],
                check=True,
                capture_output=True,
                text=True,
            )
            self.log(f"Converted: {aac_file.name} -> {m4a_file.name}")

            # Remove original .aac file after successful conversion
            aac_file.unlink()
            self.log(f"Removed original: {aac_file.name}")

            return m4a_file
        except subprocess.CalledProcessError as e:
            self.log(f"Error: Failed to convert {aac_file}: {e.stderr}")
            return None
        except Exception as e:
            self.log(f"Error: Could not convert {aac_file}: {e}")
            return None

    def find_and_convert_aac_files(self, directory: str = ".") -> list[Path]:
        """Find all .aac files and convert them to .m4a"""
        path = Path(directory)
        aac_files = list(path.glob("*.aac"))

        if not aac_files:
            return []

        self.log(f"Found {len(aac_files)} .aac file(s) to convert")

        converted_files = []
        for aac_file in aac_files:
            m4a_file = self.convert_aac_to_m4a(aac_file)
            if m4a_file:
                converted_files.append(m4a_file)

        return converted_files

    def extract_youtube_video_id(self, url: str) -> str | None:
        """Extract YouTube video ID from URL

        Supported URL patterns:
        - https://www.youtube.com/watch?v=VIDEO_ID
        - https://youtu.be/VIDEO_ID
        - https://m.youtube.com/watch?v=VIDEO_ID

        Returns:
            Video ID (11 characters) if found, None otherwise
        """
        match = re.search(
            r"(?:youtube\.com/watch\?v=|youtu\.be/)([A-Za-z0-9_-]{11})", url
        )
        return match.group(1) if match else None

    def extract_bandcamp_url_info(self, url: str) -> dict | None:
        """Extract Bandcamp URL information

        Supported URL patterns:
        - https://LABEL.bandcamp.com/album/ALBUM-SLUG
        - https://LABEL.bandcamp.com/track/TRACK-SLUG

        Returns:
            dict with 'label_slug', 'type' ('album' or 'track'), 'slug' if valid URL
            None if not a valid Bandcamp URL
        """
        match = re.match(r"https?://([^.]+)\.bandcamp\.com/(album|track)/([^/?]+)", url)
        if match:
            return {
                "label_slug": match.group(1),
                "type": match.group(2),  # 'album' or 'track'
                "slug": match.group(3),
            }
        return None

    def get_thumbnail_path_for_file(self, filepath: Path, video_id: str) -> Path:
        """Determine thumbnail filename for a file

        Naming strategy:
        - Single file in directory: cover.jpg
        - Multiple files: youtube_{VIDEO_ID}.jpg

        Args:
            filepath: Path to audio file
            video_id: YouTube video ID

        Returns:
            Path to thumbnail file
        """
        directory = filepath.parent
        audio_files = self.find_audio_files(str(directory))

        if len(audio_files) == 1:
            return directory / "cover.jpg"
        else:
            return directory / f"youtube_{video_id}.jpg"

    def get_bandcamp_artwork_path_for_file(
        self, filepath: Path, url_info: dict
    ) -> Path:
        """Determine artwork filename for Bandcamp

        Naming strategy:
        - Single file: cover.jpg
        - Multiple files from same album: cover.jpg (shared)
        - Multiple files from different albums: bandcamp_{label}_{slug}.jpg

        Args:
            filepath: Path to audio file
            url_info: Dict from extract_bandcamp_url_info()

        Returns:
            Path to artwork file
        """
        directory = filepath.parent
        audio_files = self.find_audio_files(str(directory))

        if len(audio_files) == 1:
            return directory / "cover.jpg"
        else:
            # Create unique identifier from URL
            identifier = f"{url_info['label_slug']}_{url_info['slug']}"
            return directory / f"bandcamp_{identifier}.jpg"

    def get_youtube_video_info(self, video_id: str) -> dict | None:
        """Get YouTube video information including resolution metadata

        Args:
            video_id: YouTube video ID (11 characters)

        Returns:
            Dictionary with keys:
                - best_video_width: Width of highest quality video format
                - best_video_height: Height of highest quality video format
                - best_thumb_width: Width of highest quality thumbnail
                - best_thumb_height: Height of highest quality thumbnail
                - duration: Video duration in seconds
                - title: Video title
            Returns None if extraction fails
        """
        try:
            import yt_dlp

            url = f"https://www.youtube.com/watch?v={video_id}"
            ydl_opts = {
                "quiet": True,
                "no_warnings": True,
                "skip_download": True,
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)

            # Find best video format
            video_formats = [
                f
                for f in info.get("formats", [])
                if f.get("vcodec") != "none" and f.get("width") and f.get("height")
            ]

            best_video = None
            if video_formats:
                best_video = max(
                    video_formats, key=lambda f: (f.get("height", 0), f.get("width", 0))
                )

            # Find best thumbnail
            thumbnails = [
                t
                for t in info.get("thumbnails", [])
                if t.get("width") and t.get("height")
            ]

            best_thumb = None
            if thumbnails:
                best_thumb = max(
                    thumbnails, key=lambda t: (t.get("width", 0) * t.get("height", 0))
                )

            return {
                "best_video_width": best_video.get("width") if best_video else None,
                "best_video_height": best_video.get("height") if best_video else None,
                "best_thumb_width": best_thumb.get("width") if best_thumb else None,
                "best_thumb_height": best_thumb.get("height") if best_thumb else None,
                "best_thumb_url": best_thumb.get("url") if best_thumb else None,
                "duration": info.get("duration"),
                "title": info.get("title"),
            }

        except Exception as e:
            self.log(f"Warning: Failed to get video info: {e}")
            return None

    def download_youtube_thumbnail(
        self,
        video_id: str,
        output_path: Path,
        crop: bool = False,
        interactive: bool = True,
    ) -> bool:
        """Download YouTube artwork using smart resolution-based strategy

        Strategy:
        1. Get video and thumbnail resolution information
        2. If resolutions match: use thumbnail (fast)
        3. If resolutions differ: extract frame from video (better quality)
           - Default to 5 seconds into video
           - Allow user to preview and adjust timestamp interactively

        Args:
            video_id: YouTube video ID (11 characters)
            output_path: Path where artwork should be saved
            crop: Whether to crop the artwork to square (default: False)
            interactive: Whether to prompt for user input (default: True)

        Returns:
            True if successful, False otherwise
        """
        # Step 1: Get video information
        video_info = self.get_youtube_video_info(video_id)

        if not video_info:
            self.log("Warning: Could not get video info, falling back to thumbnail")
            use_frame_extraction = False
        else:
            # Step 2: Compare resolutions
            video_width = video_info.get("best_video_width")
            video_height = video_info.get("best_video_height")
            thumb_width = video_info.get("best_thumb_width")
            thumb_height = video_info.get("best_thumb_height")

            if video_width and video_height and thumb_width and thumb_height:
                video_res = video_width * video_height
                thumb_res = thumb_width * thumb_height

                print(f"\nVideo resolution: {video_width}x{video_height}")
                print(f"Thumbnail resolution: {thumb_width}x{thumb_height}")

                if video_res == thumb_res:
                    print("-> Resolutions match. Using thumbnail (faster).")
                    use_frame_extraction = False
                else:
                    print(
                        f"-> Video resolution is {'higher' if video_res > thumb_res else 'lower'}. Using video frame for best quality."
                    )
                    use_frame_extraction = True
            else:
                self.log("Warning: Incomplete resolution info, using thumbnail")
                use_frame_extraction = False

        # Step 3: Extract artwork based on strategy
        if use_frame_extraction:
            # Interactive frame extraction
            timestamp = self.ask_frame_timestamp(
                video_id, output_path, default_timestamp=5.0, interactive=interactive
            )

            if timestamp is None:
                # User cancelled, fall back to thumbnail
                print("Falling back to thumbnail...")
                use_frame_extraction = False
            else:
                # Extract frame at selected timestamp
                success = self.download_youtube_frame(
                    video_id, output_path, timestamp=timestamp, crop=crop
                )
                return success

        # Fall back to traditional thumbnail download
        if not use_frame_extraction:
            # If we have the URL from video_info, download directly (ensures highest quality)
            if video_info and video_info.get("best_thumb_url"):
                try:
                    from io import BytesIO

                    import requests
                    from PIL import Image

                    thumb_url = video_info["best_thumb_url"]
                    response = requests.get(thumb_url, timeout=30)
                    response.raise_for_status()

                    # Save to temporary path
                    temp_path = output_path.with_suffix(".temp.jpg")
                    with open(temp_path, "wb") as f:
                        f.write(response.content)

                    downloaded_path = temp_path

                    # Verify actual image size matches metadata
                    img = Image.open(downloaded_path)
                    actual_width, actual_height = img.size
                    img.close()

                    expected_width = video_info.get("best_thumb_width")
                    expected_height = video_info.get("best_thumb_height")

                    if (
                        actual_width != expected_width
                        or actual_height != expected_height
                    ):
                        print(f"Warning: Thumbnail metadata mismatch!")
                        print(f"  Expected: {expected_width}x{expected_height}")
                        print(f"  Actual: {actual_width}x{actual_height}")

                        # Check if video has higher resolution
                        video_width = video_info.get("best_video_width")
                        video_height = video_info.get("best_video_height")
                        if video_width and video_height:
                            video_res = video_width * video_height
                            actual_res = actual_width * actual_height

                            if video_res > actual_res:
                                print(
                                    f"-> Video resolution ({video_width}x{video_height}) is higher. Switching to frame extraction."
                                )
                                # Clean up downloaded thumbnail
                                downloaded_path.unlink()
                                # Switch to frame extraction
                                use_frame_extraction = True
                                # Re-run frame extraction
                                timestamp = self.ask_frame_timestamp(
                                    video_id, output_path, default_timestamp=5.0
                                )
                                if timestamp is not None:
                                    success = self.download_youtube_frame(
                                        video_id,
                                        output_path,
                                        timestamp=timestamp,
                                        crop=crop,
                                    )
                                    return success
                                else:
                                    # User cancelled, use the downloaded thumbnail anyway
                                    print(
                                        "Using downloaded thumbnail despite resolution mismatch."
                                    )
                                    use_frame_extraction = False
                            else:
                                print(
                                    "-> Video resolution is not higher. Using downloaded thumbnail."
                                )

                except Exception as e:
                    self.log(
                        f"Warning: Failed to download thumbnail from URL: {e}, falling back to yt-dlp"
                    )
                    # Fall back to yt-dlp method
                    video_info = None

            # Fallback: use yt-dlp (when video_info not available or URL download failed)
            if not video_info or not video_info.get("best_thumb_url"):
                try:
                    import yt_dlp

                    temp_path = output_path.with_suffix("")
                    ydl_opts = {
                        "skip_download": True,
                        "writethumbnail": True,
                        "outtmpl": str(temp_path),
                        "quiet": True,
                        "no_warnings": True,
                    }

                    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                        url = f"https://www.youtube.com/watch?v={video_id}"
                        ydl.download([url])

                    # Find downloaded thumbnail (yt-dlp adds extension)
                    downloaded_files = list(
                        temp_path.parent.glob(f"{temp_path.name}.*")
                    )
                    if not downloaded_files:
                        raise Exception("Thumbnail not downloaded")

                    downloaded_path = downloaded_files[0]

                except Exception as e:
                    self.log(f"Warning: Failed to download thumbnail: {e}")
                    return False

            # Process the thumbnail
            try:
                from PIL import Image

                if crop:
                    # Crop to square (center crop)
                    img = Image.open(downloaded_path)
                    width, height = img.size

                    if width > height:
                        left = (width - height) // 2
                        img_cropped = img.crop((left, 0, left + height, height))
                    else:
                        top = (height - width) // 2
                        img_cropped = img.crop((0, top, width, top + width))

                    # Save as JPEG
                    img_cropped.save(output_path, "JPEG", quality=95)

                    # Clean up temporary file
                    if downloaded_path != output_path:
                        downloaded_path.unlink()
                else:
                    # Keep original, just move/rename
                    if downloaded_path != output_path:
                        # Re-save as JPEG to ensure consistent format
                        img = Image.open(downloaded_path)
                        img.save(output_path, "JPEG", quality=95)
                        downloaded_path.unlink()

            except Exception as e:
                self.log(f"Warning: Failed to process thumbnail: {e}")
                # Keep original if processing fails
                if downloaded_path != output_path:
                    shutil.move(str(downloaded_path), str(output_path))

            return True

    def download_youtube_frame(
        self,
        video_id: str,
        output_path: Path,
        timestamp: float = 5.0,
        crop: bool = False,
    ) -> bool:
        """Download a specific frame from YouTube video

        Args:
            video_id: YouTube video ID (11 characters)
            output_path: Path where frame should be saved
            timestamp: Time in seconds to extract frame from (default: 5.0)
            crop: Whether to crop to square (default: False)

        Returns:
            True if successful, False otherwise
        """
        try:
            import yt_dlp

            url = f"https://www.youtube.com/watch?v={video_id}"
            temp_video = output_path.parent / f"temp_{video_id}.mp4"

            # Try segmented download first (faster), with fallback to full video
            download_success = False
            actual_video_path = None
            seek_time = timestamp

            # Strategy 1: Try downloading a short segment (fast but may fail)
            try:
                start_time = max(0, timestamp - 1)
                end_time = timestamp + 9

                ydl_opts = {
                    "format": "bestvideo[ext=mp4]",
                    "outtmpl": str(temp_video.with_suffix("")),
                    "quiet": True,
                    "no_warnings": True,
                    "download_ranges": lambda info, ydl: [
                        {"start_time": start_time, "end_time": end_time}
                    ],
                }

                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    ydl.download([url])

                # Find the downloaded video file
                video_files = list(temp_video.parent.glob(f"temp_{video_id}*"))
                if video_files:
                    actual_video_path = video_files[0]
                    seek_time = 1.0  # We downloaded starting 1 second before timestamp
                    download_success = True

            except Exception as segment_error:
                self.log(f"Segmented download failed: {segment_error}")
                # Clean up any partial files from failed segment download
                for temp_file in temp_video.parent.glob(f"temp_{video_id}*"):
                    try:
                        temp_file.unlink()
                    except Exception:
                        pass

            # Strategy 2: If segmented download failed, download beginning of full video
            if not download_success:
                self.log("Falling back to full video download...")
                try:
                    # Download first 30 seconds of video (should cover most use cases)
                    ydl_opts = {
                        "format": "bestvideo[ext=mp4]",
                        "outtmpl": str(temp_video.with_suffix("")),
                        "quiet": True,
                        "no_warnings": True,
                        "external_downloader": "ffmpeg",
                        "external_downloader_args": [
                            "-t",
                            "30",
                        ],  # Download first 30 seconds
                    }

                    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                        ydl.download([url])

                    # Find the downloaded video file
                    video_files = list(temp_video.parent.glob(f"temp_{video_id}*"))
                    if not video_files:
                        raise Exception("Failed to download video")

                    actual_video_path = video_files[0]
                    seek_time = timestamp  # Seek directly to timestamp in the downloaded portion
                    download_success = True

                except Exception as full_error:
                    self.log(f"Full video download also failed: {full_error}")
                    raise

            if not download_success or actual_video_path is None:
                raise Exception("All download strategies failed")

            # Extract frame using ffmpeg
            subprocess.run(
                [
                    "ffmpeg",
                    "-y",
                    "-ss",
                    str(seek_time),
                    "-i",
                    str(actual_video_path),
                    "-frames:v",
                    "1",
                    "-q:v",
                    "2",  # High quality
                    str(output_path.with_suffix(".temp.jpg")),
                ],
                check=True,
                capture_output=True,
            )

            # Clean up video file
            actual_video_path.unlink()

            # Process the extracted frame
            from PIL import Image

            temp_frame = output_path.with_suffix(".temp.jpg")

            if crop:
                # Crop to square (center crop)
                img = Image.open(temp_frame)
                width, height = img.size

                if width > height:
                    left = (width - height) // 2
                    img_cropped = img.crop((left, 0, left + height, height))
                else:
                    top = (height - width) // 2
                    img_cropped = img.crop((0, top, width, top + width))

                img_cropped.save(output_path, "JPEG", quality=95)
            else:
                # Keep original aspect ratio
                img = Image.open(temp_frame)
                img.save(output_path, "JPEG", quality=95)

            # Clean up temporary frame
            if temp_frame.exists():
                temp_frame.unlink()

            return True

        except Exception as e:
            self.log(f"Warning: Failed to download frame: {e}")
            # Clean up any temporary files
            for pattern in [f"temp_{video_id}.*", "*.temp.jpg"]:
                for temp_file in output_path.parent.glob(pattern):
                    try:
                        temp_file.unlink()
                    except Exception:
                        pass
            return False

    def download_bandcamp_artwork(
        self, url: str, output_path: Path, crop: bool = False
    ) -> bool:
        """Download Bandcamp artwork and optionally crop to square

        Args:
            url: Bandcamp album or track URL
            output_path: Path where artwork should be saved
            crop: Whether to crop to square (default: False)

        Returns:
            True if successful, False otherwise
        """
        try:
            import yt_dlp

            temp_path = output_path.with_suffix("")
            ydl_opts = {
                "skip_download": True,
                "writethumbnail": True,
                "outtmpl": str(temp_path),
                "quiet": True,
                "no_warnings": True,
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([url])

            # Find downloaded artwork (yt-dlp adds extension)
            downloaded_files = list(temp_path.parent.glob(f"{temp_path.name}.*"))
            if not downloaded_files:
                raise Exception("Artwork not downloaded")

            downloaded_path = downloaded_files[0]

        except Exception as e:
            self.log(f"Warning: Failed to download Bandcamp artwork: {e}")
            return False

        # Process artwork (same logic as YouTube)
        try:
            from PIL import Image

            if crop:
                # Bandcamp artwork is usually already square, but crop if needed
                img = Image.open(downloaded_path)
                width, height = img.size

                if width > height:
                    left = (width - height) // 2
                    img_cropped = img.crop((left, 0, left + height, height))
                else:
                    top = (height - width) // 2
                    img_cropped = img.crop((0, top, width, top + width))

                img_cropped.save(output_path, "JPEG", quality=95)

                if downloaded_path != output_path:
                    downloaded_path.unlink()
            else:
                # Keep original, convert to JPEG
                if downloaded_path != output_path:
                    img = Image.open(downloaded_path)
                    img.save(output_path, "JPEG", quality=95)
                    downloaded_path.unlink()

        except Exception as e:
            self.log(f"Warning: Failed to process Bandcamp artwork: {e}")
            # Keep original if processing fails
            if downloaded_path != output_path:
                shutil.move(str(downloaded_path), str(output_path))

        return True

    def parse_filename(self, filename: str) -> dict[str, any]:
        """Parse metadata from filename

        Supported patterns (spaces are flexible, 1+ spaces allowed):
        - Label - Artist - Title [ID].mp3 -> label="Label", artist="Artist", title="Title", bandcamp_id="ID"
        - Label - Album - 01 Artist - Title.mp3 -> label="Label", album="Album", track=1, artist="Artist", title="Title"
        - Label - Album - 01 - Title.mp3 -> label="Label", album="Album", track=1, title="Title"
        - Artist - Title [YOUTUBE_ID].mp3 -> artist="Artist", title="Title", comment="https://www.youtube.com/watch?v=YOUTUBE_ID"
        - 1. Artist - Title.mp3 -> track=1, artist="Artist", title="Title"
        - 01 Artist - Title.mp3 -> track=1, artist="Artist", title="Title"
        - 01  - Title.mp3 -> track=1, artist="", title="Title"
        - 01 Title.mp3 -> track=1, artist="", title="Title"
        - Artist - Title.mp3 -> artist="Artist", title="Title"
        - Title.mp3 -> title="Title"
        """
        # Remove extension
        name = Path(filename).stem

        track = None
        artist = None
        title = None
        album = None
        label = None
        bandcamp_id = None
        comment = None

        # Check for YouTube ID pattern [VIDEO_ID] at the end
        # YouTube IDs are typically 11 characters: alphanumeric, hyphens, underscores
        youtube_match = re.search(r"\[([A-Za-z0-9_-]{11})\]$", name)
        if youtube_match:
            video_id = youtube_match.group(1)
            comment = f"https://www.youtube.com/watch?v={video_id}"
            # Remove the [VIDEO_ID] part from the name for further parsing
            name = name[: youtube_match.start()].strip()

        # Try patterns in order of specificity (spaces: 1+ allowed)
        # Pattern 0: "Label - Artist - Title [ID]" (Bandcamp format)
        match = re.match(r"^(.+?)\s+-\s+(.+?)\s+-\s+(.+?)\s+\[(\d+)\]$", name)
        if match:
            label = match.group(1).strip()
            artist = match.group(2).strip()
            title = match.group(3).strip()
            bandcamp_id = match.group(4).strip()
            return {
                "track": None,
                "artist": artist if artist else None,
                "title": title if title else None,
                "label": label if label else None,
                "bandcamp_id": bandcamp_id if bandcamp_id else None,
                "comment": comment,
            }

        # Pattern 0a: "Label - Album - 01 Artist - Title" (Label + Album + Track + Artist + Title)
        match = re.match(r"^(.+?)\s+-\s+(.+?)\s+-\s+(\d+)\s+(.+?)\s+-\s+(.+)$", name)
        if match:
            label = match.group(1).strip()
            album = match.group(2).strip()
            track = int(match.group(3))
            artist = match.group(4).strip()
            title = match.group(5).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": album if album else None,
                "label": label if label else None,
                "comment": comment,
            }

        # Pattern 0b: "Label - Album - 01 - Title" (Label + Album + Track + Title, no artist)
        match = re.match(r"^(.+?)\s+-\s+(.+?)\s+-\s+(\d+)\s+-\s+(.+)$", name)
        if match:
            label = match.group(1).strip()
            album = match.group(2).strip()
            track = int(match.group(3))
            title = match.group(4).strip()
            return {
                "track": track,
                "artist": None,
                "title": title if title else None,
                "album": album if album else None,
                "label": label if label else None,
                "comment": comment,
            }

        # Pattern 1: "1. Artist - Title" (track with dot + artist + title)
        match = re.match(r"^(\d+)\.\s+(.+?)\s+-\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = match.group(2).strip()
            title = match.group(3).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 2: "01 Artist - Title" (track + artist + title)
        match = re.match(r"^(\d+)\s+(.+?)\s+-\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = match.group(2).strip()
            title = match.group(3).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 3: "01  - Title" (track + title, no artist)
        match = re.match(r"^(\d+)\s+-\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = ""
            title = match.group(2).strip()
            return {
                "track": track,
                "artist": None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 4: "01 Title" (track + title, no separator)
        match = re.match(r"^(\d+)\s+(.+)$", name)
        if match:
            track = int(match.group(1))
            artist = ""
            title = match.group(2).strip()
            return {
                "track": track,
                "artist": None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 5: "Artist - Title" (artist + title, no track)
        match = re.match(r"^(.+?)\s+-\s+(.+)$", name)
        if match:
            track = None
            artist = match.group(1).strip()
            title = match.group(2).strip()
            return {
                "track": track,
                "artist": artist if artist else None,
                "title": title if title else None,
                "album": None,
                "comment": comment,
            }

        # Pattern 6: "Title" (title only)
        title = name.strip()
        return {
            "track": None,
            "artist": None,
            "title": title if title else None,
            "album": None,
            "comment": comment,
        }

    def read_tags(self, filepath: Path) -> dict[str, any]:
        """Read tags from an audio file"""
        ext = filepath.suffix.lower()
        tags = {
            "filename": filepath.name,
            "track": None,
            "artist": None,
            "title": None,
            "album": None,
            "albumartist": None,
            "genre": None,
            "year": None,
            "artwork": None,
            "compilation": None,
            "label": None,
            "bandcamp_id": None,
            "disc": None,
            "comment": None,
        }

        try:
            if ext == ".mp3":
                audio = MP3(str(filepath), ID3=ID3)
                if audio.tags:
                    # Track number
                    if "TRCK" in audio.tags:
                        track_str = str(audio.tags["TRCK"])
                        tags["track"] = (
                            int(track_str.split("/")[0])
                            if "/" in track_str
                            else int(track_str)
                        )

                    # Disc number
                    if "TPOS" in audio.tags:
                        disc_str = str(audio.tags["TPOS"])
                        tags["disc"] = (
                            int(disc_str.split("/")[0])
                            if "/" in disc_str
                            else int(disc_str)
                        )

                    # Text fields
                    if "TIT2" in audio.tags:
                        tags["title"] = str(audio.tags["TIT2"])
                    if "TPE1" in audio.tags:
                        tags["artist"] = str(audio.tags["TPE1"])
                    if "TALB" in audio.tags:
                        tags["album"] = str(audio.tags["TALB"])
                    if "TPE2" in audio.tags:
                        tags["albumartist"] = str(audio.tags["TPE2"])
                    if "TCON" in audio.tags:
                        tags["genre"] = str(audio.tags["TCON"])
                    if "TDRC" in audio.tags:
                        tags["year"] = int(str(audio.tags["TDRC"]))
                    if "TCMP" in audio.tags:
                        tags["compilation"] = str(audio.tags["TCMP"]) == "1"

                    # Artwork (APIC frames can have different descriptions like "APIC:Cover", "APIC:", etc.)
                    has_artwork = any(
                        key.startswith("APIC:") for key in audio.tags.keys()
                    )
                    if has_artwork:
                        tags["artwork"] = "<embedded>"

                    # Custom tags (TXXX frames)
                    if "TXXX:LABEL" in audio.tags:
                        tags["label"] = str(audio.tags["TXXX:LABEL"])
                    if "TXXX:BANDCAMP_ID" in audio.tags:
                        tags["bandcamp_id"] = str(audio.tags["TXXX:BANDCAMP_ID"])

                    # Comment (COMM frame)
                    if "COMM::eng" in audio.tags:
                        tags["comment"] = str(audio.tags["COMM::eng"])
                    elif "COMM::" in audio.tags:
                        tags["comment"] = str(audio.tags["COMM::"])

            elif ext == ".m4a":
                audio = MP4(str(filepath))
                if audio.tags:
                    # Track number
                    if "\xa9nam" in audio.tags:
                        tags["title"] = audio.tags["\xa9nam"][0]
                    if "\xa9ART" in audio.tags:
                        tags["artist"] = audio.tags["\xa9ART"][0]
                    if "\xa9alb" in audio.tags:
                        tags["album"] = audio.tags["\xa9alb"][0]
                    if "aART" in audio.tags:
                        tags["albumartist"] = audio.tags["aART"][0]
                    if "\xa9gen" in audio.tags:
                        tags["genre"] = audio.tags["\xa9gen"][0]
                    if "\xa9day" in audio.tags:
                        tags["year"] = int(audio.tags["\xa9day"][0])
                    if "trkn" in audio.tags:
                        tags["track"] = audio.tags["trkn"][0][0]
                    if "disk" in audio.tags:
                        tags["disc"] = audio.tags["disk"][0][0]
                    if "cpil" in audio.tags:
                        tags["compilation"] = bool(audio.tags["cpil"][0])

                    # Artwork
                    if "covr" in audio.tags:
                        tags["artwork"] = "<embedded>"

                    # Comment
                    if "\xa9cmt" in audio.tags:
                        tags["comment"] = audio.tags["\xa9cmt"][0]

                    # Custom tags (freeform)
                    if "----:com.apple.iTunes:LABEL" in audio.tags:
                        tags["label"] = audio.tags["----:com.apple.iTunes:LABEL"][
                            0
                        ].decode("utf-8")
                    if "----:com.apple.iTunes:BANDCAMP_ID" in audio.tags:
                        tags["bandcamp_id"] = audio.tags[
                            "----:com.apple.iTunes:BANDCAMP_ID"
                        ][0].decode("utf-8")

        except Exception as e:
            self.log(f"Warning: Could not read tags from {filepath}: {e}")

        # If track, artist, title, album, label, bandcamp_id, or comment is missing, try to parse from filename
        # Or if prefer_filename is True, always parse and use filename values
        if (
            self.prefer_filename
            or tags["track"] is None
            or tags["artist"] is None
            or tags["title"] is None
            or tags["album"] is None
            or tags["label"] is None
            or tags["bandcamp_id"] is None
            or tags["comment"] is None
        ):
            parsed = self.parse_filename(filepath.name)

            if (self.prefer_filename or tags["track"] is None) and parsed.get(
                "track"
            ) is not None:
                tags["track"] = parsed["track"]
            if (self.prefer_filename or tags["artist"] is None) and parsed.get(
                "artist"
            ) is not None:
                tags["artist"] = parsed["artist"]
            if (self.prefer_filename or tags["title"] is None) and parsed.get(
                "title"
            ) is not None:
                tags["title"] = parsed["title"]
            if (self.prefer_filename or tags["album"] is None) and parsed.get(
                "album"
            ) is not None:
                tags["album"] = parsed["album"]
            if (self.prefer_filename or tags["label"] is None) and parsed.get(
                "label"
            ) is not None:
                tags["label"] = parsed["label"]
            if (self.prefer_filename or tags["bandcamp_id"] is None) and parsed.get(
                "bandcamp_id"
            ) is not None:
                tags["bandcamp_id"] = parsed["bandcamp_id"]
            if (self.prefer_filename or tags["comment"] is None) and parsed.get(
                "comment"
            ) is not None:
                tags["comment"] = parsed["comment"]

        return tags

    def _compare_tags(
        self, current: dict[str, any], expected: dict[str, any]
    ) -> dict[str, tuple[any, any]]:
        """
        Compare current tags with expected tags and return differences.
        Returns a dict of {field: (current_value, expected_value)} for fields that differ.
        """
        differences = {}

        # Fields to compare (excluding 'filename' which is not a tag)
        comparable_fields = [
            "track",
            "artist",
            "title",
            "album",
            "albumartist",
            "genre",
            "year",
            "compilation",
            "label",
            "bandcamp_id",
            "artwork",
            "disc",
            "comment",
        ]

        for field in comparable_fields:
            expected_value = expected.get(field)
            current_value = current.get(field)

            # Special handling for artwork
            if field == "artwork":
                # If YAML specifies a file path, we need to check if it matches embedded artwork
                if expected_value and expected_value != "<embedded>":
                    # YAML wants to set artwork from file
                    if current_value != "<embedded>":
                        differences[field] = (current_value, expected_value)
                elif expected_value == "<embedded>":
                    # YAML expects embedded artwork to exist
                    if current_value != "<embedded>":
                        differences[field] = (current_value, expected_value)
                # If expected_value is None, we don't care about artwork
                continue

            # For other fields, only compare if expected value is not None
            # (None means "not specified in YAML, don't modify")
            if expected_value is not None and current_value != expected_value:
                differences[field] = (current_value, expected_value)

        return differences

    def write_tags(self, filepath: Path, tags: dict[str, any]) -> bool:
        """Write tags to an audio file"""
        ext = filepath.suffix.lower()

        # Read current tags to check if update is needed
        current_tags = self.read_tags(filepath)
        differences = self._compare_tags(current_tags, tags)

        if self.dry_run:
            if differences:
                self.log(f"Would update tags for: {filepath}")
            # Don't output anything if tags are already up-to-date
            return True

        # Skip update if no differences
        if not differences:
            return True

        try:
            if ext == ".mp3":
                audio = MP3(str(filepath), ID3=ID3)

                # Create ID3 tag if it doesn't exist
                if audio.tags is None:
                    audio.add_tags()

                # Set tags
                if tags.get("title"):
                    audio.tags.add(TIT2(encoding=3, text=tags["title"]))
                if tags.get("artist"):
                    audio.tags.add(TPE1(encoding=3, text=tags["artist"]))
                if tags.get("album"):
                    audio.tags.add(TALB(encoding=3, text=tags["album"]))
                if tags.get("albumartist"):
                    audio.tags.add(TPE2(encoding=3, text=tags["albumartist"]))
                if tags.get("genre"):
                    audio.tags.add(TCON(encoding=3, text=tags["genre"]))
                if tags.get("year"):
                    audio.tags.add(TDRC(encoding=3, text=str(tags["year"])))
                if tags.get("track"):
                    audio.tags.add(TRCK(encoding=3, text=str(tags["track"])))
                if tags.get("disc"):
                    audio.tags.add(TPOS(encoding=3, text=str(tags["disc"])))
                if tags.get("compilation") is not None:
                    audio.tags.add(
                        TCMP(encoding=3, text="1" if tags["compilation"] else "0")
                    )

                # Custom tags
                if tags.get("label"):
                    audio.tags.add(TXXX(encoding=3, desc="LABEL", text=tags["label"]))
                if tags.get("bandcamp_id"):
                    audio.tags.add(
                        TXXX(encoding=3, desc="BANDCAMP_ID", text=tags["bandcamp_id"])
                    )

                # Comment
                if tags.get("comment"):
                    audio.tags.add(
                        COMM(encoding=3, lang="eng", desc="", text=tags["comment"])
                    )

                # Artwork
                if tags.get("artwork") and tags["artwork"] != "<embedded>":
                    artwork_path = Path(tags["artwork"])
                    if artwork_path.exists():
                        with open(artwork_path, "rb") as f:
                            audio.tags.add(
                                APIC(
                                    encoding=3,
                                    mime=(
                                        "image/jpeg"
                                        if artwork_path.suffix.lower()
                                        in [".jpg", ".jpeg"]
                                        else "image/png"
                                    ),
                                    type=3,  # Cover (front)
                                    desc="Cover",
                                    data=f.read(),
                                )
                            )

                audio.save()

            elif ext == ".m4a":
                audio = MP4(str(filepath))

                # Set tags
                if tags.get("title"):
                    audio.tags["\xa9nam"] = tags["title"]
                if tags.get("artist"):
                    audio.tags["\xa9ART"] = tags["artist"]
                if tags.get("album"):
                    audio.tags["\xa9alb"] = tags["album"]
                if tags.get("albumartist"):
                    audio.tags["aART"] = tags["albumartist"]
                if tags.get("genre"):
                    audio.tags["\xa9gen"] = tags["genre"]
                if tags.get("year"):
                    audio.tags["\xa9day"] = str(tags["year"])
                if tags.get("track"):
                    audio.tags["trkn"] = [(tags["track"], 0)]
                if tags.get("disc"):
                    audio.tags["disk"] = [(tags["disc"], 0)]
                if tags.get("compilation") is not None:
                    audio.tags["cpil"] = [tags["compilation"]]

                # Comment
                if tags.get("comment"):
                    audio.tags["\xa9cmt"] = tags["comment"]

                # Custom tags
                if tags.get("label"):
                    audio.tags["----:com.apple.iTunes:LABEL"] = tags["label"].encode(
                        "utf-8"
                    )
                if tags.get("bandcamp_id"):
                    audio.tags["----:com.apple.iTunes:BANDCAMP_ID"] = tags[
                        "bandcamp_id"
                    ].encode("utf-8")

                # Artwork
                if tags.get("artwork") and tags["artwork"] != "<embedded>":
                    artwork_path = Path(tags["artwork"])
                    if artwork_path.exists():
                        with open(artwork_path, "rb") as f:
                            cover_data = f.read()
                            if artwork_path.suffix.lower() == ".png":
                                audio.tags["covr"] = [
                                    MP4Cover(
                                        cover_data, imageformat=MP4Cover.FORMAT_PNG
                                    )
                                ]
                            else:
                                audio.tags["covr"] = [
                                    MP4Cover(
                                        cover_data, imageformat=MP4Cover.FORMAT_JPEG
                                    )
                                ]

                audio.save()

            self.log(f"Updated tags for: {filepath}")
            return True

        except Exception as e:
            self.log(f"Error: Could not write tags to {filepath}: {e}")
            return False

    def sanitize_filename(self, name: str) -> str:
        """Sanitize filename by removing invalid characters"""
        invalid_chars = '<>:"/\\|?*'
        for char in invalid_chars:
            name = name.replace(char, "_")
        return name

    def generate_filename(
        self, tags: dict[str, any], max_track: int | None = None
    ) -> str:
        """Generate filename from tags

        Args:
            tags: Dictionary of tag values
            max_track: Maximum track number (for padding). If None, uses 2 digits minimum.
        """
        track = tags.get("track", "")
        disc = tags.get("disc", "")
        artist = tags.get("artist", "")
        title = tags.get("title", "Unknown Title")

        # Get original extension
        original_filename = tags.get("filename", ".mp3")
        ext = Path(original_filename).suffix

        # Determine padding width based on max_track
        # Always use at least 2 digits, even if max_track is single digit
        if max_track is not None and max_track > 0:
            padding = max(2, len(str(max_track)))
        else:
            padding = 2  # Default to 2 digits

        # Build track prefix with optional disc number
        # Disc number is always 2 digits: 01-01, 02-03, etc.
        track_prefix = ""
        if track:
            if disc:
                track_prefix = f"{disc:02d}-{track:0{padding}d}"
            else:
                track_prefix = f"{track:0{padding}d}"

        # Build filename based on available metadata
        # Hyphens use 1 space before and after, except track-only uses 2 spaces before hyphen
        if track_prefix and artist:
            # Format: 01-01 Artist - Title.mp3 (with disc) or 01 Artist - Title.mp3 (without disc)
            filename = f"{track_prefix} {artist} - {title}{ext}"
        elif track_prefix:
            # Format: 01-01  - Title.mp3 (no artist, 2 spaces before hyphen)
            filename = f"{track_prefix}  - {title}{ext}"
        elif artist:
            # Format: Artist - Title.mp3 (no track)
            filename = f"{artist} - {title}{ext}"
        else:
            # Format: Title.mp3 (no track, no artist)
            filename = f"{title}{ext}"

        return self.sanitize_filename(filename)

    def rename_file(self, old_path: Path, new_filename: str) -> Path | None:
        """Rename a file"""
        new_path = old_path.parent / new_filename

        if old_path == new_path:
            return old_path

        if self.dry_run:
            self.log(f"Would rename: {old_path.name} -> {new_filename}")
            return new_path

        try:
            old_path.rename(new_path)
            self.log(f"Renamed: {old_path.name} -> {new_filename}")
            return new_path
        except Exception as e:
            self.log(f"Error: Could not rename {old_path}: {e}")
            return None

    def compare_tags(
        self, current: dict, yaml_data: dict, filepath: Path | None = None
    ) -> dict:
        """Compare current tags with YAML data and return differences

        For artwork, compares actual file contents if filepath is provided
        """
        diff = {}
        all_keys = set(current.keys()) | set(yaml_data.keys())

        for key in all_keys:
            current_val = current.get(key)
            yaml_val = yaml_data.get(key)

            # Special handling for artwork comparison
            if key == "artwork" and filepath:
                # If current has embedded artwork and YAML specifies a file
                if (
                    current_val == "<embedded>"
                    and yaml_val
                    and yaml_val != "<embedded>"
                ):
                    # Compare actual file contents
                    if self.compare_artwork(filepath, yaml_val):
                        # Artwork is the same, skip diff
                        continue
                # If both are "<embedded>", they're the same
                elif current_val == "<embedded>" and yaml_val == "<embedded>":
                    continue

            if current_val != yaml_val:
                diff[key] = {"current": current_val, "yaml": yaml_val}

        return diff

    def show_diff(self, yaml_file: str = "tagger.yaml"):
        """Show differences between current state and YAML file"""
        if not os.path.exists(yaml_file):
            self.log(f"Error: {yaml_file} not found")
            return

        # First, convert any .aac files to .m4a
        self.find_and_convert_aac_files()

        # Load YAML file
        with open(yaml_file, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)

        # Validate YAML structure
        try:
            config = TaggerConfig(**data)
        except ValidationError as e:
            self.log(f"Error: YAML validation failed for {yaml_file}:")
            for error in e.errors():
                field = " -> ".join(str(x) for x in error["loc"])
                self.log(f"  {field}: {error['msg']}")
            return

        # Get defaults from YAML
        defaults = (
            config.defaults.model_dump(exclude_none=True, mode="python")
            if config.defaults
            else {}
        )

        # Get current files
        files = self.find_audio_files()
        current_files = {f.name: f for f in files}

        # Get YAML files
        yaml_files = {f.filename: f for f in config.files}

        # Find files only in YAML (deleted files)
        deleted_files = set(yaml_files.keys()) - set(current_files.keys())

        # Find files only in current directory (new files)
        new_files = set(current_files.keys()) - set(yaml_files.keys())

        # Find common files (potentially modified)
        common_files = set(current_files.keys()) & set(yaml_files.keys())

        has_changes = False

        # Show deleted files
        if deleted_files:
            has_changes = True
            print("\n" + self.color("=" * 60, "dim"))
            print(
                self.color(
                    "DELETED FILES (in YAML but not in directory):", "red", "bold"
                )
            )
            print(self.color("=" * 60, "dim"))
            for filename in sorted(deleted_files):
                print(f"  {self.color('-', 'red')} {self.color(filename, 'red')}")

        # Show new files
        if new_files:
            has_changes = True
            print("\n" + self.color("=" * 60, "dim"))
            print(
                self.color("NEW FILES (in directory but not in YAML):", "green", "bold")
            )
            print(self.color("=" * 60, "dim"))
            for filename in sorted(new_files):
                filepath = current_files[filename]
                current_tags = self.read_tags(filepath)
                print(f"\n  {self.color(filename, 'green', 'bold')}:")
                for key, value in current_tags.items():
                    if key != "filename" and value is not None:
                        print(f"    {self.color(key, 'cyan')}: {value}")

        # Show modified files
        modified_files = []
        for filename in sorted(common_files):
            filepath = current_files[filename]
            current_tags = self.read_tags(filepath)

            # Get YAML data for this file
            yaml_file_data = next(
                f.model_dump(exclude_none=True, mode="python")
                for f in config.files
                if f.filename == filename
            )

            # Merge defaults with file-specific data
            yaml_tags = defaults | yaml_file_data

            # Compare tags (pass filepath for artwork comparison)
            diff = self.compare_tags(current_tags, yaml_tags, filepath)

            if diff:
                modified_files.append((filename, diff))

        if modified_files:
            has_changes = True
            print("\n" + self.color("=" * 60, "dim"))
            print(
                self.color(
                    "MODIFIED FILES (differences between current and YAML):",
                    "yellow",
                    "bold",
                )
            )
            print(self.color("=" * 60, "dim"))
            for filename, diff in modified_files:
                print(f"\n  {self.color(filename, 'yellow', 'bold')}:")
                for key, values in diff.items():
                    if key == "filename":
                        continue
                    current_val = values["current"]
                    yaml_val = values["yaml"]
                    print(f"    {self.color(key, 'cyan')}:")
                    print(
                        f"      {self.color('current:', 'green')} {self.color(str(current_val), 'green')}"
                    )
                    print(
                        f"      {self.color('yaml:   ', 'red')} {self.color(str(yaml_val), 'red')}"
                    )

        if not has_changes:
            print("\n" + self.color("=" * 60, "dim"))
            print(self.color("NO CHANGES DETECTED", "green", "bold"))
            print(self.color("=" * 60, "dim"))
            print(
                f"\n{self.color('', 'green')} Current directory state matches {self.color(yaml_file, 'cyan')}"
            )

    def generate_yaml(self, output_file: str = "tagger.yaml", interactive: bool = True):
        """Generate YAML file from current directory audio files

        Args:
            output_file: Output YAML filename
            interactive: If True, prompt user for preferences when conflicts exist
        """
        # First, convert any .aac files to .m4a
        self.find_and_convert_aac_files()

        files = self.find_audio_files()

        if not files:
            self.log("No audio files found in current directory")
            return

        self.log(f"Found {len(files)} audio file(s)")

        # Check if any files have both embedded tags and parseable filenames
        # If so, ask user which to prefer
        if interactive and not self.dry_run:
            has_conflict = False
            for filepath in files:
                # Temporarily read tags without filename parsing
                old_prefer = self.prefer_filename
                self.prefer_filename = False
                tags_only = self.read_tags(filepath)
                self.prefer_filename = old_prefer

                parsed = self.parse_filename(filepath.name)

                # Check if both have artist and title
                if (
                    tags_only.get("artist")
                    and parsed.get("artist")
                    and tags_only.get("artist") != parsed.get("artist")
                ) or (
                    tags_only.get("title")
                    and parsed.get("title")
                    and tags_only.get("title") != parsed.get("title")
                ):
                    has_conflict = True
                    break

            if has_conflict:
                print(
                    "\n"
                    + self.color(
                        "Some files have different information in tags vs. filenames.",
                        "yellow",
                    )
                )
                print(
                    "Which source should be preferred when generating the YAML file?\n"
                )
                print("  1. Embedded tags (default)")
                print("  2. Filenames")
                print()

                while True:
                    choice = input("Enter your choice (1 or 2) [1]: ").strip()
                    if choice == "" or choice == "1":
                        self.prefer_filename = False
                        break
                    elif choice == "2":
                        self.prefer_filename = True
                        break
                    else:
                        print("Invalid choice. Please enter 1 or 2.")

        # Read tags from all files
        entries = []
        artwork_downloads = {}  # Track thumbnails to download (video_id: path)
        bandcamp_artwork_downloads = (
            {}
        )  # Track Bandcamp artwork to download (url: path)

        for filepath in files:
            tags = self.read_tags(filepath)

            # Check for YouTube URL in comment field
            comment = tags.get("comment")
            if comment and "youtube.com" in comment:
                video_id = self.extract_youtube_video_id(comment)
                if video_id:
                    thumbnail_path = self.get_thumbnail_path_for_file(
                        filepath, video_id
                    )

                    # Skip if thumbnail already exists
                    if not thumbnail_path.exists():
                        artwork_downloads[video_id] = thumbnail_path

                    # Set artwork if not already present
                    if not tags.get("artwork"):
                        tags["artwork"] = str(thumbnail_path.name)  # Relative path

            # Check for Bandcamp URL in comment field
            if comment and "bandcamp.com" in comment:
                url_info = self.extract_bandcamp_url_info(comment)
                if url_info:
                    artwork_path = self.get_bandcamp_artwork_path_for_file(
                        filepath, url_info
                    )

                    # Skip if artwork already exists
                    if not artwork_path.exists():
                        # Use full URL as key for deduplication
                        bandcamp_artwork_downloads[comment] = artwork_path

                    # Set artwork if not already present
                    if not tags.get("artwork"):
                        tags["artwork"] = str(artwork_path.name)  # Relative path

            # Remove None values
            entry = {k: v for k, v in tags.items() if v is not None}
            entries.append(entry)

        # Download thumbnails (execute mode only)
        if not self.dry_run and artwork_downloads:
            self.log(f"Downloading {len(artwork_downloads)} YouTube thumbnail(s)...")

            # Determine crop setting
            crop_choice = None
            if self.thumbnail_crop == "square":
                crop_choice = True
            elif self.thumbnail_crop == "none":
                crop_choice = False
            # else: auto mode, will ask for each thumbnail

            for idx, (video_id, path) in enumerate(artwork_downloads.items(), 1):
                print(
                    f"  [{idx}/{len(artwork_downloads)}] {video_id}...",
                    end="",
                    flush=True,
                )

                # Download thumbnail first
                if self.download_youtube_thumbnail(
                    video_id, path, crop=False, interactive=interactive
                ):
                    print("  Downloaded")

                    # Determine whether to crop this thumbnail
                    should_crop = crop_choice
                    if should_crop is None:  # auto mode
                        should_crop = self.ask_thumbnail_crop(path)

                    # Apply crop if needed
                    if should_crop:
                        try:
                            from PIL import Image

                            img = Image.open(path)
                            width, height = img.size

                            # Only crop if not already square
                            if width != height:
                                if width > height:
                                    left = (width - height) // 2
                                    img_cropped = img.crop(
                                        (left, 0, left + height, height)
                                    )
                                else:
                                    top = (height - width) // 2
                                    img_cropped = img.crop((0, top, width, top + width))

                                img_cropped.save(path, "JPEG", quality=95)
                                print(f"     Cropped to square")
                        except Exception as e:
                            self.log(f"    Warning: Failed to crop: {e}")
                else:
                    print("  Failed")

        # Download Bandcamp artwork (execute mode only)
        if not self.dry_run and bandcamp_artwork_downloads:
            self.log(
                f"Downloading {len(bandcamp_artwork_downloads)} Bandcamp artwork(s)..."
            )

            # Determine crop setting (reuse same logic as YouTube)
            crop_choice = None
            if self.thumbnail_crop == "square":
                crop_choice = True
            elif self.thumbnail_crop == "none":
                crop_choice = False
            # else: auto mode, will ask for each artwork

            for idx, (url, path) in enumerate(bandcamp_artwork_downloads.items(), 1):
                print(
                    f"  [{idx}/{len(bandcamp_artwork_downloads)}] {url}...",
                    end="",
                    flush=True,
                )

                # Download artwork first
                if self.download_bandcamp_artwork(url, path, crop=False):
                    print("  Downloaded")

                    # Determine whether to crop
                    should_crop = crop_choice
                    if should_crop is None:  # auto mode
                        should_crop = self.ask_thumbnail_crop(
                            path
                        )  # Reuse existing function

                    # Apply crop if needed (same logic as YouTube)
                    if should_crop:
                        try:
                            from PIL import Image

                            img = Image.open(path)
                            width, height = img.size

                            # Only crop if not already square
                            if width != height:
                                if width > height:
                                    left = (width - height) // 2
                                    img_cropped = img.crop(
                                        (left, 0, left + height, height)
                                    )
                                else:
                                    top = (height - width) // 2
                                    img_cropped = img.crop((0, top, width, top + width))

                                img_cropped.save(path, "JPEG", quality=95)
                                print(f"     Cropped to square")
                        except Exception as e:
                            self.log(f"    Warning: Failed to crop: {e}")
                else:
                    print("  Failed")

        # Extract common fields to defaults
        common_fields = [
            "album",
            "albumartist",
            "genre",
            "year",
            "artwork",
            "compilation",
            "label",
            "bandcamp_id",
            "disc",
            "comment",
        ]
        defaults = {}

        if len(entries) > 1:  # Only extract defaults if there are multiple files
            for field in common_fields:
                # Get all values for this field (excluding None)
                values = [entry.get(field) for entry in entries if field in entry]

                # If all files have the same non-None value, move to defaults
                if (
                    values
                    and len(values) == len(entries)
                    and len(set(str(v) for v in values)) == 1
                ):
                    defaults[field] = values[0]

            # Remove common fields from individual entries
            if defaults:
                for entry in entries:
                    for field in defaults:
                        entry.pop(field, None)

        # Sort entries by track number (entries without track number go last)
        def get_track_sort_key(entry):
            track = entry.get("track")
            if track is None:
                # Check if track is in defaults
                track = defaults.get("track")
            # Return tuple: (has_track, track_number)
            # Entries without track go last (True > False)
            if track is None:
                return (True, 0)
            return (False, track)

        entries_sorted = sorted(entries, key=get_track_sort_key)

        # Create YAML structure
        yaml_data = {}
        if defaults:
            yaml_data["defaults"] = defaults
        yaml_data["files"] = entries_sorted

        # Validate YAML structure
        try:
            config = TaggerConfig(**yaml_data)
            # Convert back to dict for YAML serialization
            yaml_data = config.model_dump(exclude_none=True, mode="python")
        except ValidationError as e:
            self.log(f"Error: Generated YAML validation failed:")
            for error in e.errors():
                field = " -> ".join(str(x) for x in error["loc"])
                self.log(f"  {field}: {error['msg']}")
            sys.exit(1)

        # Generate YAML string with schema comment
        schema_url = "https://raw.githubusercontent.com/delphinus/homebrew-tagger/main/tagger.schema.json"
        schema_comment = f"# yaml-language-server: $schema={schema_url}\n\n"

        yaml_str = yaml.dump(
            yaml_data, allow_unicode=True, default_flow_style=False, sort_keys=False
        )

        if self.dry_run:
            # Show artwork download summary if any
            total_downloads = len(artwork_downloads) + len(bandcamp_artwork_downloads)
            if total_downloads > 0:
                self.log("")
                self.log("Artwork Download Summary:")
                self.log("-" * 60)

                if artwork_downloads:
                    self.log(f"YouTube Thumbnails: {len(artwork_downloads)} file(s)")
                    for idx, (video_id, path) in enumerate(
                        artwork_downloads.items(), 1
                    ):
                        self.log(f"  [{idx}] {video_id} -> {path.name}")

                if bandcamp_artwork_downloads:
                    self.log(
                        f"Bandcamp Artwork: {len(bandcamp_artwork_downloads)} file(s)"
                    )
                    for idx, (url, path) in enumerate(
                        bandcamp_artwork_downloads.items(), 1
                    ):
                        # Extract readable display name from URL
                        url_info = self.extract_bandcamp_url_info(url)
                        if url_info:
                            display_name = f"{url_info['label_slug']}/{url_info['type']}/{url_info['slug']}"
                        else:
                            display_name = url[:50] + "..." if len(url) > 50 else url
                        self.log(f"  [{idx}] {display_name} -> {path.name}")

                self.log("-" * 60)
                self.log(
                    f"Total: {total_downloads} artwork file(s) would be downloaded with -e flag"
                )
                self.log("")

            self.log(f"Would create {output_file} with content:")
            print("\n" + "=" * 60)
            print(schema_comment + yaml_str)
            print("=" * 60)
        else:
            with open(output_file, "w", encoding="utf-8") as f:
                f.write(schema_comment)
                f.write(yaml_str)
            self.log(f"Created {output_file}")

    def apply_yaml(self, yaml_file: str):
        """Apply tags and filenames from YAML file"""
        # First, convert any .aac files to .m4a
        self.find_and_convert_aac_files()

        if not os.path.exists(yaml_file):
            self.log(f"Error: YAML file not found: {yaml_file}")
            sys.exit(1)

        # Load YAML
        with open(yaml_file, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)

        # Validate YAML structure
        try:
            config = TaggerConfig(**data)
            self.log("YAML validation successful")
        except ValidationError as e:
            self.log(f"Error: YAML validation failed for {yaml_file}:")
            for error in e.errors():
                field = " -> ".join(str(x) for x in error["loc"])
                self.log(f"  {field}: {error['msg']}")
            self.log("\nCommon issues:")
            self.log(
                "  - Check for typos in field names (e.g., 'default' should be 'defaults')"
            )
            self.log("  - Ensure all required fields are present")
            self.log(
                "  - Verify data types (e.g., year should be a number, not a string)"
            )
            sys.exit(1)

        # Get defaults if present
        defaults = (
            config.defaults.model_dump(exclude_none=True, mode="python")
            if config.defaults
            else {}
        )

        files_data = [
            f.model_dump(exclude_none=True, mode="python") for f in config.files
        ]
        self.log(f"Processing {len(files_data)} file(s) from {yaml_file}")

        # Track Bandcamp artwork to download (url: path)
        bandcamp_artwork_downloads = {}

        # Calculate maximum track number for padding
        max_track = 0
        for file_data in files_data:
            merged_data = defaults | file_data
            track = merged_data.get("track")
            if track is not None and track > max_track:
                max_track = track

        for file_data in files_data:
            if "filename" not in file_data:
                self.log("Warning: Skipping entry without 'filename'")
                continue

            original_filename = file_data["filename"]
            filepath = Path(original_filename)

            if not filepath.exists():
                self.log(f"Warning: File not found: {original_filename}")
                continue

            # Merge defaults with file-specific data (file-specific takes priority)
            merged_data = defaults | file_data

            # Check for Bandcamp URL in comment field
            comment = merged_data.get("comment")
            if comment and "bandcamp.com" in comment:
                url_info = self.extract_bandcamp_url_info(comment)
                if url_info:
                    artwork_path = self.get_bandcamp_artwork_path_for_file(
                        filepath, url_info
                    )

                    # Skip if artwork already exists
                    if not artwork_path.exists():
                        # Use full URL as key for deduplication
                        bandcamp_artwork_downloads[comment] = artwork_path

                    # Set artwork if not already present
                    if not merged_data.get("artwork"):
                        merged_data["artwork"] = str(artwork_path.name)  # Relative path

            # Write tags
            self.write_tags(filepath, merged_data)

            # Generate new filename with proper track padding
            new_filename = self.generate_filename(
                merged_data, max_track if max_track > 0 else None
            )

            # Rename file if needed
            new_path = self.rename_file(filepath, new_filename)

            # Update YAML entry with new filename for future reference
            if new_path and not self.dry_run:
                file_data["filename"] = new_path.name

        # Download Bandcamp artwork (execute mode only)
        if not self.dry_run and bandcamp_artwork_downloads:
            self.log(
                f"Downloading {len(bandcamp_artwork_downloads)} Bandcamp artwork(s)..."
            )

            # Determine crop setting (reuse same logic as YouTube)
            crop_choice = None
            if self.thumbnail_crop == "square":
                crop_choice = True
            elif self.thumbnail_crop == "none":
                crop_choice = False
            # else: auto mode, will ask for each artwork

            for idx, (url, path) in enumerate(bandcamp_artwork_downloads.items(), 1):
                print(
                    f"  [{idx}/{len(bandcamp_artwork_downloads)}] {url}...",
                    end="",
                    flush=True,
                )

                # Download artwork first
                if self.download_bandcamp_artwork(url, path, crop=False):
                    print("  Downloaded")

                    # Determine whether to crop
                    should_crop = crop_choice
                    if should_crop is None:
                        # Auto mode: ask user
                        while True:
                            print(
                                "    Crop to square? (y/n/a=always/n=never): ",
                                end="",
                                flush=True,
                            )
                            choice = input().strip().lower()
                            if choice in ["y", "yes"]:
                                should_crop = True
                                break
                            elif choice in ["n", "no"]:
                                should_crop = False
                                break
                            elif choice == "a":
                                should_crop = True
                                crop_choice = True  # Remember for next files
                                break
                            elif choice == "v":
                                should_crop = False
                                crop_choice = False  # Remember for next files
                                break
                            else:
                                print("    Invalid choice. Please enter y/n/a/v.")

                    # Crop if requested
                    if should_crop:
                        try:
                            from PIL import Image

                            img = Image.open(path)
                            width, height = img.size

                            if width != height:
                                # Crop to center square
                                if width > height:
                                    left = (width - height) // 2
                                    img_cropped = img.crop(
                                        (left, 0, left + height, height)
                                    )
                                else:
                                    top = (height - width) // 2
                                    img_cropped = img.crop((0, top, width, top + width))

                                img_cropped.save(path, "JPEG", quality=95)
                                print(f"     Cropped to square")
                        except Exception as e:
                            self.log(f"    Warning: Failed to crop: {e}")
                else:
                    print("  Failed")

        # Show artwork download summary in dry-run mode
        if self.dry_run and bandcamp_artwork_downloads:
            self.log("")
            self.log("Artwork Download Summary:")
            self.log("-" * 60)
            self.log(f"Bandcamp Artwork: {len(bandcamp_artwork_downloads)} file(s)")
            for idx, (url, path) in enumerate(bandcamp_artwork_downloads.items(), 1):
                # Extract readable display name from URL
                url_info = self.extract_bandcamp_url_info(url)
                if url_info:
                    display_name = f"{url_info['label_slug']}/{url_info['type']}/{url_info['slug']}"
                else:
                    display_name = url[:50] + "..." if len(url) > 50 else url
                self.log(f"  [{idx}] {display_name} -> {path.name}")
            self.log("-" * 60)
            self.log(
                f"Total: {len(bandcamp_artwork_downloads)} artwork file(s) would be downloaded with -e flag"
            )
            self.log("")

        # Update YAML file with new filenames
        if not self.dry_run:
            # Sort files by track number (files without track number go last)
            def get_track_sort_key(file_data):
                merged = defaults | file_data
                track = merged.get("track")
                # Return tuple: (has_track, track_number)
                # Files without track go last (True > False)
                if track is None:
                    return (True, 0)
                return (False, track)

            files_data_sorted = sorted(files_data, key=get_track_sort_key)

            # Update the files list in data with the sorted files_data
            data["files"] = files_data_sorted
            with open(yaml_file, "w", encoding="utf-8") as f:
                yaml.dump(
                    data,
                    f,
                    allow_unicode=True,
                    default_flow_style=False,
                    sort_keys=False,
                )
            self.log(f"Updated {yaml_file} with new filenames")


def handle_reminder_command(args, tagger_instance):
    """Handle reminder subcommand

    Args:
        args: Parsed command line arguments
        tagger_instance: Tagger instance with execute/no_color settings
    """
    import platform

    # Platform check
    if platform.system() != "Darwin":
        tagger_instance.log("Error: Reminder functionality requires macOS")
        sys.exit(1)

    # Import reminder module
    try:
        import reminder
    except ImportError:
        tagger_instance.log("Error: reminder module not found")
        sys.exit(1)

    if args.reminder_command == "add":
        handle_reminder_add(args, tagger_instance)
    else:
        tagger_instance.log("Error: Unknown reminder command")
        sys.exit(1)


def handle_reminder_add(args, tagger_instance):
    """Handle 'tagger reminder add' command

    Title resolution priority:
    1. args.title (manual override)
    2. Tagger metadata (if --match-audio and file found)
    3. URL extraction (yt-dlp or HTML)

    Args:
        args: Parsed command line arguments
        tagger_instance: Tagger instance
    """
    import reminder

    url = args.url
    title = args.title
    list_name = args.list
    notes = args.notes

    # Try to get title from tagger metadata if requested
    if not title and args.match_audio:
        title = extract_title_from_tagger_metadata(url, tagger_instance)
        if title:
            tagger_instance.log(f"Found title from audio file: {title}")

    # Fallback to URL extraction
    if not title:
        tagger_instance.log("Extracting title from URL...")
        title = reminder.extract_title_from_url(url)
        if not title:
            tagger_instance.log("Error: Could not extract title from URL")
            tagger_instance.log("Please specify --title manually")
            sys.exit(1)
        tagger_instance.log(f"Extracted title: {title}")

    # Get reminder list
    if not list_name:
        if tagger_instance.dry_run:
            tagger_instance.log("Would show interactive list selection")
            list_name = "Reminders"  # Default for dry-run
        else:
            lists = reminder.get_reminder_lists()
            if not lists:
                tagger_instance.log("Error: No reminder lists found")
                sys.exit(1)
            list_name = reminder.select_reminder_list(lists)
            if not list_name:
                sys.exit(1)

    # Dry-run preview
    if tagger_instance.dry_run:
        print("\n" + tagger_instance.color("=" * 60, "dim"))
        print(tagger_instance.color("REMINDER PREVIEW (Dry-run)", "yellow", "bold"))
        print(tagger_instance.color("=" * 60, "dim"))
        print(f"  List:  {list_name}")
        print(f"  Title: {title}")
        print(f"  URL:   {url}")
        if notes:
            print(f"  Notes: {notes}")
        print(tagger_instance.color("=" * 60, "dim"))
        print(
            f"\n{tagger_instance.color('Note:', 'cyan')} Use --execute to actually add the reminder"
        )
        return

    # Execute mode: add the reminder
    tagger_instance.log(f"Adding reminder to '{list_name}'...")
    if reminder.add_reminder(list_name, title, notes, url):
        tagger_instance.log(
            tagger_instance.color(" Successfully added reminder", "green")
        )
    else:
        tagger_instance.log(tagger_instance.color(" Failed to add reminder", "red"))
        sys.exit(1)


def extract_title_from_tagger_metadata(url, tagger_instance):
    """Extract title from tagger metadata by matching URL to audio files

    Strategy:
    1. Find audio files in current directory
    2. Check if any file's comment field matches the URL
    3. If match found, format title as "Artist - Title"

    Args:
        url: URL to match
        tagger_instance: Tagger instance

    Returns:
        Formatted title string or None
    """
    files = tagger_instance.find_audio_files()

    for filepath in files:
        tags = tagger_instance.read_tags(filepath)
        comment = tags.get("comment")

        # Check if comment field contains the URL
        if comment and url in comment:
            artist = tags.get("artist")
            title = tags.get("title")

            if artist and title:
                return f"{artist} - {title}"
            elif title:
                return title

    # Try matching by YouTube video ID extraction
    video_id = tagger_instance.extract_youtube_video_id(url)
    if video_id:
        for filepath in files:
            tags = tagger_instance.read_tags(filepath)
            comment = tags.get("comment")

            if comment and video_id in comment:
                artist = tags.get("artist")
                title = tags.get("title")

                if artist and title:
                    return f"{artist} - {title}"
                elif title:
                    return title

    return None


def main():
    # Create main parser with global options
    parser = argparse.ArgumentParser(
        description="Manage audio file tags and filenames using mutagen",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Tag management (default mode):
  tagger                        # Show diff or generate YAML (dry-run)
  tagger --execute              # Generate YAML
  tagger tagger.yaml            # Apply tags (dry-run)
  tagger --execute tagger.yaml  # Apply tags and execute

  # Reminder management (macOS only):
  tagger reminder add "https://example.com"                    # Add reminder (dry-run)
  tagger reminder add "https://example.com" --execute          # Add reminder
  tagger reminder add "https://example.com" --match-audio      # Use audio metadata for title
  tagger reminder add URL --title "Custom Title" --execute     # Add with custom title
        """,
    )

    # Global options (apply to all modes)
    parser.add_argument(
        "-e",
        "--execute",
        action="store_true",
        help="Execute changes (default is dry-run mode)",
    )

    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
    )

    parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable colored output",
    )

    # Create subparsers for different modes
    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # ========================================================================
    # Tag management mode (default)
    # ========================================================================
    tag_parser = subparsers.add_parser(
        "tag", add_help=False, help="Manage audio file tags (default mode)"
    )

    tag_parser.add_argument(
        "yaml_file",
        nargs="?",
        help="YAML file with tag information (if not provided, generates YAML from current directory)",
    )

    tag_parser.add_argument(
        "-o",
        "--output",
        default="tagger.yaml",
        help="Output YAML file name when generating (default: tagger.yaml)",
    )

    tag_parser.add_argument(
        "--prefer-filename",
        action="store_true",
        help="Prefer metadata from filenames over embedded tags when generating YAML (non-interactive mode)",
    )

    tag_parser.add_argument(
        "--thumbnail-crop",
        choices=["auto", "square", "none"],
        default="auto",
        help="YouTube thumbnail cropping: 'auto' (ask for each), 'square' (crop to square), 'none' (keep original) (default: auto)",
    )

    # ========================================================================
    # Reminder mode (macOS only)
    # ========================================================================
    reminder_parser = subparsers.add_parser(
        "reminder", help="Manage macOS Reminders (macOS only)"
    )

    reminder_subparsers = reminder_parser.add_subparsers(
        dest="reminder_command", help="Reminder commands"
    )

    # reminder add subcommand
    add_parser = reminder_subparsers.add_parser(
        "add", help="Add URL to macOS Reminders"
    )

    add_parser.add_argument("url", help="URL to add to reminders")

    add_parser.add_argument(
        "-t",
        "--title",
        help="Reminder title (if not provided, will be extracted from URL or audio metadata)",
    )

    add_parser.add_argument(
        "-l",
        "--list",
        help="Reminder list name (if not provided, will show selection menu)",
    )

    add_parser.add_argument("-n", "--notes", help="Additional notes for the reminder")

    add_parser.add_argument(
        "--match-audio",
        action="store_true",
        help="Try to match URL with audio files in current directory and use their metadata for title",
    )

    # Parse arguments with backward compatibility handling
    # Check if first positional arg is a known subcommand
    import sys as sys_module

    known_subcommands = {"reminder", "tag"}
    argv = sys_module.argv[1:]  # Skip script name

    # Find first non-flag argument
    first_positional = None
    for arg in argv:
        if not arg.startswith("-") and not arg.startswith("--"):
            first_positional = arg
            break

    # If first positional is not a known subcommand, prepend 'tag' for backward compat
    if first_positional and first_positional not in known_subcommands:
        # This is likely a yaml file, so we're in legacy mode
        argv_modified = []
        inserted_tag = False
        for arg in argv:
            if (
                not inserted_tag
                and not arg.startswith("-")
                and not arg.startswith("--")
            ):
                argv_modified.append("tag")
                inserted_tag = True
            argv_modified.append(arg)
        args = parser.parse_args(argv_modified)
    else:
        args = parser.parse_args()

    # Default to tag mode if no subcommand specified
    if args.command is None:
        args.command = "tag"
        # Set default values for tag mode options
        args.yaml_file = None
        args.output = "tagger.yaml"
        args.prefer_filename = False
        args.thumbnail_crop = "auto"

    # Create Tagger instance (used by all modes for consistent logging/colors)
    tagger = Tagger(
        execute=args.execute,
        no_color=args.no_color,
        prefer_filename=getattr(args, "prefer_filename", False),
        thumbnail_crop=getattr(args, "thumbnail_crop", "auto"),
    )

    # Route to appropriate handler
    if args.command == "reminder":
        handle_reminder_command(args, tagger)
    else:  # 'tag' mode (default)
        if args.yaml_file:
            # Apply mode
            tagger.apply_yaml(args.yaml_file)
        else:
            # Generate/Diff mode
            # If tagger.yaml exists in current directory, show diff instead of generating
            if os.path.exists("tagger.yaml") and not args.execute:
                tagger.show_diff("tagger.yaml")
            else:
                # If --prefer-filename is set, skip interactive mode
                interactive = not args.prefer_filename
                tagger.generate_yaml(args.output, interactive=interactive)


if __name__ == "__main__":
    main()
